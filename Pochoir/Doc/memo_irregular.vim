0) employing the overlapping 'Register_Tile_Kernels()' to implement
partial function evaluation, e.g.:
   if (g0) { F = 0; }
   if (g1) { F = f(u^n); }
   if (g0 || g1) { u^{n+1} = u^n + F; }
   By this specification, the kernels generated by Pochoir should have
   the effect:
   if (g0) { u^{n+1} = u^n + 0; }
   if (g1) { u^{n+1} = u^n + f(u^n); }

0) For JITting, currently, we will generate the code of kernels to an
external disk files, then invoke icc on the disk file, then dynamically
load the executable from disk to memory. But what if we can do everything
directly in the memory without writing/reading anything to the external
disk? The key issue: How to invoke icc over a region of data memory? How
to make the executables generated by icc in the original data cache into
an executable in instruction cache (so could execute it)?

0) Automatically infer the largest region which has the homogeneous
pattern/tiling from a given bit-map
    - User will specify a strip of space with corresponding guard/updating
    function to generate the bit-map.
    - Pochoir traverse all the points in this strip of space by
    divide-and-conquer to decide whether to generate a separate clone
    for the homogeneous region or just use the generic clone for a
    small enough inhomogeneous region (tiny region) ---- Just In Time
    Compilation
    - Assuming we don't need to preserve the order of different function
    pattern for now.
    - Problem: What if the user specifies that do some kernel after t >
    1000 (original guard function), which is not easily applicable for
    an analysis on simple strip of space.

============================================================================================
Three notations for conditional guards in inner loops:
1) exclusive_if: the construct denotes the if () else if ()
... structure. The regions guarded by this construct are mutually
exclusive with other exclusive_if's
2) inclusive_if: indicates a region that may overlap with other regions
guaded by exclusive_if's or inclusive_if's
3) tiny_inclusive_if: the construct denotes a region that may overlap with
other regions, while the area / amount of points in the region is tiny.

Example:

Pochoir specification:

exclusive_if (g0) {k0;}
exclusive_if (g1) {k1;}
inclusive_if (g2) {k2;}
inclusive_if (g3) {k3;}
tiny_inclusive_if (g4) {k4;}
tiny_inclusive_if (g5) {k5;}

Equivalent looping implementation:

for ... {
    if (g0) {
        k0;
    } else if (g1) {
        k1;
    }
    if (g2) {k2;}
    if (g3) {k3;}
    // The user's hint indicates that the sub-regions guarded by g4 and g5 are 
    // very tiny fraction of the entire domain
    if (g4) {k4;} 
    if (g5) {k5;}
} /* end for */

The code clones automatically generated by Pochoir:

1) if (g0 & !g2 & !g3 & ! g4 & ! g5) : k0
2) if (g0 & !g2 & g3 & ! g4 & ! g5) : k0; k3;
3) if (g0 & g2 & !g3 & ! g4 & ! g5) : k0; k2;
4) if (g0 & g2 & g3 & ! g4 & ! g5) : k0; k2; k3;
5) if (g1 & !g2 & !g3 & ! g4 & ! g5) : k1
6) if (g1 & !g2 & g3 & ! g4 & ! g5) : k1; k3;
7) if (g1 & g2 & !g3 & ! g4 & ! g5) : k1; k2;
8) if (g1 & g2 & g3 & ! g4 & ! g5) : k1; k2; k3;
9) if (!g0 & !g1 & !g2 & !g3 & ! g4 & ! g5) : nop
10) if (!g0 & !g1 & !g2 & g3 & ! g4 & ! g5) : k3;
11) if (!g0 & !g1 & g2 & !g3 & ! g4 & ! g5) : k2;
12) if (!g0 & !g1 & g2 & g3 & ! g4 & ! g5) : k2; k3;
13) if (g4 || g5) : 
    // Since the user indicates that the regions guarded by g4 and g5 are quite
    // small, so it doesn't matter a lot to put all conditional guards check in
    // the inner loops
    if (g0) { 
        k0; 
    } else if (g1) {
        k1; 
    }
    if (g2) k2;
    if (g3) k3;
    if (g4) k4;
    if (g5) k5;

So, in summary, if there are 'm' exclusive_if's, 'n' inclusive_if's, and
'k' tiny_inclusive_if's, Pochoir compiler should generate "m x 2^n + 1"
code clones.

