\secput{benchmark}{Some Applications used for Benchmarking Pochoir}

\punt{
\subsection{Non-periodic 2D heat equation}

\punt{
\begin{figure}%
%\begin{minipage}{21pc}
\begin{center}%
 \mbox{\includegraphics[clip,width=\textwidth]{figures/periodic-stencils.eps}}%
 \vspace{-0.4cm}
 \caption{Periodic rectangular 2D grids representing: {\bf(a)} a Torus (see Figure \ref{fig:torus}), and 
  {\bf(b)} a Klein Bottle. Dotted lines connect each cell on the
  left boundary to its adjacent cell on the right boundary while broken lines connect adjacent cells
  on the top and the bottom boundaries.}%
 \label{fig:periodic-stencils}%
\end{center}%
%\end{minipage}
\end{figure}%
}

\punt{
\subsecput{heat2Dtorus}{(Periodic 2D) heat diffusion on a torus}

\begin{figure}%
%\begin{minipage}{21pc}
\begin{center}%
 \mbox{\includegraphics[clip,width=\textwidth]{figures/torus.eps}}%
 \vspace{-0.4cm}
 \caption{Periodicity on a Torus: {\bf(a)} fundamental polygon of a torus;
 {\bf(b)} bend the polygon so that the two dotted sides touch with their 
 arrow heads facing the same direction, and thus obtain a cylinder; and
 {\bf(c)} bend the cylinder so that its circular top and bottom ends touch
 with their arrow heads facing the same direction, and thus obtain
 a torus.}%
 \label{fig:torus}%
\end{center}%
%\end{minipage}
\end{figure}%
}

 \vspace{-0.3cm}
 \begin{equation}
  \textrm{mod}{\left(x,~ N\right)} = \left\{ \begin{array}{ll}
                   \textrm{mod}{\left(x + N,~ N\right)} & \textrm{if $x < 0$,}\\
                   \textrm{mod}{\left(x - N,~ N\right)} & \textrm{if $x \geq N$,}\\
                   x & \textrm{otherwise.}
                   \end{array} \right.
 \label{eq:mod}
 \end{equation} 

 \vspace{-0.3cm}
 \begin{equation}
  {\langle~i,~ j~\rangle}_{\textrm{torus}} = \langle~ \textrm{mod}{\left(i,~ N_x\right)},~ \textrm{mod}{\left(j,~ N_y\right)} ~\rangle
 \label{eq:torus}
 \end{equation} 
}


\punt{
\subsection{Heat Diffusion on a Klein Bottle}

\punt{
\begin{figure}%
%\begin{minipage}{21pc}
\begin{center}%
 \mbox{\includegraphics[clip,width=\textwidth]{figures/klein.eps}}%
 \vspace{-0.4cm}
 \caption{Periodicity on a Klein Bottle: {\bf(a)} fundamental polygon of a klein bottle;
 {\bf(b)} bend the polygon so that the two dotted sides touch with their 
 arrow heads facing the same direction, and thus obtain a cylinder; and
 {\bf(c)} make the cylinder's circular top and bottom ends touch
 with their arrow heads facing the same direction by bending it
 and passing it through its side, and thus obtain a klein bottle 
 \cite{WikiKleinBottle10}.}%
 \label{fig:klein}%
\end{center}%
%\end{minipage}
\end{figure}%
}

 In this section we consider evaulating 2D heat equation on a 2D grid
 with adjacency relationships among boundary cells giving rise to
 a Klein bottle shape.
 % as shown in Figure \ref{fig:periodic-stencils}(b) which turns out to be a Klein bottle.  
 Assuming that the Klein bottle is generated from a finite 2D
 grid with grid coordinates lying in $[ 0, N_x ) \times [ 0, N_y )$,
 the following equation maps any point $\langle~i,~ j~\rangle$ from
 the underlying infinite grid to the corresponding point on the Klein
 bottle.
  

 \vspace{-0.3cm}
 \begin{equation}
  {\langle~i,~ j~\rangle}_{\textrm{klein bottle}} = \left\{ \begin{array}{ll}
                   \langle~ \textrm{mod}{\left(i,~ N_x\right)},~ j ~\rangle 
                    & \textrm{if $j \in [0, N_y)$,}\\
                   \left\langle~\begin{array}{c} N_x - 1 - \textrm{mod}{\left(i,~ N_x\right)},\\ 
                                           \textrm{mod}{\left(j,~ N_y\right)}\end{array} ~\right\rangle 
                    & \textrm{otherwise.}
                   \end{array} \right.
 \label{eq:klein}
 \end{equation} 

 Now in order to evaluate 2D heat equation
 on a Klein bottle we only need to modify the boundary function
 based on Equation \ref{eq:klein}.
% as shown in Figure \ref{fig:2DHeatKB}.
}
% punt ends


\subsection{Periodic Game of Life on a 2D square}

 The {\em Game of Life}, developed by John Conway \cite{Gardner70,BerlekampCoGu03}
 is a no-player\footnote{i.e., the initial configuration alone
 determines how the game evolves without any further input} 
 never-ending game played on an infinite 2D orthogonal grid. Each cell in the
 grid starts with an initial configuration of either {\em dead}
 or {\em alive}. The initial configuration defines the first
 generation of cells. Each subsequent generation evolves from
 the previous generation based on how many live neighbors each
 cell had in that generation. The eight adjacent cells of any
 given cell are considered its neighbors. Live cells may die
 due to under-population or overcrowding, and dead cells
 may become live again due to reproduction. Though the rules
 of evolution are extremely simple (see below), the game can give rise
 to very interesting patterns based on the initial configuration.
 It has been shown in \cite{BerlekampCoGu03} that the Game of Life can
 even imitate a universal Turing machine.
 
 We have implemented Game of Life as a stencil on a finite torus. By
 $alive(~t,~ i,~ j~)$ we denote the state of the grid cell $(~i, ~j~)$
 at time step $t$ (i.e., generation $t$) which is either {\tt{true}}
 or {\tt{false}}. By $neighbors(~t,~ i,~ j~)$ we denote the number of
 live neighbors of cell $(~i, ~j~)$ at time step $t$.  The evolution
 equation for $alive$ is as follows (as defined in the original game).

% \vspace{-0.3cm}
% \begin{equation}
%  neighbors(~t,~ i,~ j~) = \hspace{-0.5cm}\sum_{\begin{array}{@{}c@{}} (i', j' \in \{-1, 0, 1\})\\ 
%         \wedge (\langle i', j' \rangle \neq \langle 0, 0 \rangle)\end{array}}
%            {\hspace{-0.9cm}|alive( t, \textrm{mod}( i + i' ), \textrm{mod}( j + j' ) )|}
% \label{eq:neighbors}
% \end{equation} 


 \vspace{-0.3cm}
 \begin{equation}
  alive(~t,~ i,~ j~) = \left\{ \begin{array}{@{}ll}
                   {\tt{false}} & \textrm{if ~$neighbors(t - 1, i, j) < 2$,}\\
                   {\tt{false}} & \textrm{if ~$neighbors(t - 1, i, j) > 3$,}\\
                   {\tt{true}} & \textrm{if ~$neighbors(t - 1, i, j) = 3$,}\\
                   alive(~t - 1, ~i, ~j~) & \textrm{otherwise.}
                   \end{array} \right.
 \label{eq:game-of-life}
 \end{equation} 


%\subsection{Game of Life on Klein Bottle}


% \subsection{3DFD}


\subsection{American Put Stock Option Pricing (APOP)}
% \racnote{APOP: 1D heat equation type floating point stencil, but with coefficients based on index in the space dimension}

The holder of an {\em American put option} has the right 
(but not the obligation) to sell to the writer a prescribed 
asset for a prescribed price (known as the {\em{exercise price}}) 
at any time between the start date and a prescribed expiry date 
in the future \cite{Higham04}. The holder then faces the problem
of determining the {\em option price}, i.e., the amount he or she 
should pay for the privilege of holding the option. 
% One way of approximating the optimal option price is to use the 
% finite differences method as described below \cite{John06}.
The optimal option price can be approximated using the
finite differences method as described in \cite{John06}
with an update equation based on 1 dimensional aperiodic heat diffusion
equation.

\punt{
Let $S$ be the spot price, and let $T$ be the maturity time of
the option. Suppose in the finite difference calculation, $n_s$ 
is the number of steps in the space 
(i.e., stock price) dimension, and $n_t$ is the number of steps in 
the time dimension. Let $f(t, i)$ be the value of the option price
at time $t \cdot \delta{t}$ and stock price $i \cdot \delta{s}$,
where $\delta{t} = {T \over n_t}$ and $\delta{s} = {{2S} \over n_s}$. 
Then if the exercise price is $E$, the $f(t, i)$ values can be
computed using the following recurrence \cite{John06}.

 \vspace{-0.3cm}
 \begin{equation}
  f(t, i) = \left\{ \begin{array}{@{}l@{~}l@{}}
                   \max{\left\{ 0, E - i \cdot \delta{s} \right\}} & \textrm{if $t = 0$,}\\
                   E & \textrm{if $t > 0 \wedge i = 0$,}\\
                   0 & \textrm{if $t > 0 \wedge i = n_s$,}\\
                   \max{\left\{\begin{array}{@{}c@{}} c_{-1}( i ) \cdot f(t - 1, i - 1)\\
                                                    + c_{0}( i ) \cdot f(t - 1, i)\\
                                                    + c_{1}( i ) \cdot f(t - 1, i + 1),\\
                                                    E - i \cdot \delta{s} \end{array}\right\}}
                     & \textrm{otherwise.}
                   \end{array} \right.
 \label{eq:apop-stencil}
 \end{equation} 

The coefficients $c_{k}( i ), k \in \{ -1, 0, 1 \}$ in the recurrence above
depend on interest rate and volatility as well as on $T$, $n_s$ and $n_t$.
The optimal option price is given by $f( n_t, {n_s \over 2} )$
(assuming $n_s$ to be an even number).
%
}
% punt ends

\punt{
The Pochoir code for the stencil is given in Figure \ref{fig:apop}.

\begin{figure}[ht]
\begin{center-code}
\begin{cilk-listing}
Pochoir_Boundary_1D( apop_bv_1D, arr, t, i )

   if ( (i < arr.size( 0 ) - 1) || (t == 0) ) 
        return arr.get( t, i );
   else return 0;

Pochoir_Boundary_end

//
// Inputs: S = spot price, E = exercise price, 
//         r = interest rate, V = volatility, 
//         T = time to mature, 
//         ns = #steps in space dimension, 
//         nt = #steps in time dimension
//
// Output: price of American put option
//
double APOP( double S, double E, double r, 
             double V, double T, 
             int ns, int nt )
{
   ns = ns + ( ns & 1 );
   double dS = 2.0 * S / ns;
   
   Pochoir_Array<double, 1, 3> coeff(ns + 1);
   
   computeCoeffs(r, V, T, ns, nt, coeff);   
   
   Pochoir_Array<double, 1, 2> f(ns + 1);
   
   cilk_for ( int i = 0; i <= ns; ++i )
       f( 0, i ) = max( 0.0, E - i * dS );
       
   f( 1, 0 ) = E;    
       
   Pochoir<double, 1, 2> apop;       
   Pochoir_Domain I(1, ns);
   Pochoir_Shape<1> apop_shape[] 
      = { {1, 0}, {0, -1}, {0, 0}, {0, 1} };    
    
   Pochoir_kernel_1D( apop_fn, t, i )
        
       double v = coeff(-1, i) * f(t, i - 1)
                + coeff(0, i) * f(t, i)
       	        + coeff(1, i) * f(t, i + 1);
        
       f(t + 1, i) = max( v, E - i * dS );			   
  
   Pochoir_kernel_end

   apop.registerShape( apop_shape );
   apop.registerDomain( I );   
   apop.registerArray( f );    
   apop.registerBoundaryFn( f, apop_bv_1D );

   apop.run( nt, apop_fn );
    
   return f( nt, ( ns >> 1 ) );    
}
\end{cilk-listing}%
\end{center-code}%
\caption{Pochoir based C++ code for American put option pricing.}
\label{fig:apop}
\end{figure}
}
% punt ends


\subsecput{lcs}{Longest common subsequence (LCS)}

% \racnote{LCS: 1D stencil (through transformation) with a single integer field}

\begin{figure*}%
%\begin{minipage}{42pc}
\begin{center}%
 \mbox{\includegraphics[clip,width=\textwidth]{figures/lcs.eps}}%
 \vspace{-0.4cm}
 \caption{Transforming the classic LCS DP to a parallelizable stencil:
 {\bf(a)} the classic LCS grid, where each cell $(i, j)$ $[i, j > 0]$ depends 
 on cells $(i, j - 1)$, $(i - 1, j)$ and $(i - 1, j - 1)$;
 {\bf(b)} rotating the LCS grid in (a) by $45^{\circ}$ in the
 counter-clockwise direction so that no cell depends on cells
 on the same row (i.e., diagonals of (a)); and
 {\bf(c)} sliding the rows of (b) to the right
 to give it a proper stencil shape.}%
 \label{fig:lcs-trans}%
\end{center}%
%\end{minipage}
\end{figure*}%

\punt{
\begin{figure}[ht!]
\begin{center-code}
\begin{cilk-listing}
//
// Inputs: two sequences X and Y of lengths
//         nX and nY, respectively 
//
// Output: length of an LCS between X and Y
//
int LCS( int nX, char *X, int nY, char *Y )
{
   Pochoir<int, 1, 3> lcs;    
   Pochoir_Array<int, 1, 3> L(nY + 1);
   Pochoir_Domain J(0, nY + 1);
   Pochoir_Shape<1> lcs_shape[] 
      = { {2, 0}, {1, 0}, {0, -1}, {1, -1} };    
    
   L( 0, 0 ) = L( 1, 0 ) = L( 1, 1 ) = 0;
    
   Pochoir_kernel_1D( lcs_fn, t, j )
      
    int i = t + 2 - j;

    if ( ( i >= 0 ) && ( i <= nX ) )
      {                      
       if ( ( i > 0 ) && ( j > 0 ) )
         {
          if ( X[ i ] == Y[ j ] ) 
            L(t + 2, j) = 1 + L(t, j - 1);
          else 
            L(t + 2, j) = max(L(t + 1, j - 1), 
                              L(t + 1, j));
         }  
       else L(t + 2, j) = 0;
      }
                      	      
   Pochoir_kernel_end

   lcs.registerShape( lcs_shape );
   lcs.registerArray( L );    
   lcs.registerDomain( J );

   int t = nX + nY - 1;

   lcs.run( t, lcs_fn );
    
   return L( t + 1, nY );
}
\end{cilk-listing}%
\end{center-code}%
\caption{Pochoir based C++ code for computing the length of an LCS between two sequences.}
\label{fig:lcs}
\end{figure}
}
% punt ends

 Given two sequences the {\em Longest Common Subsequence} (LCS)
 problem asks for a maximum-length subsequence\footnote{A sequence 
 $Z = z_{1} z_{2} \ldots z_{k}$ is called a {\em subsequence} 
 of another sequence $X = x_{1} x_{2} \ldots x_{n}$ if there 
 exists a strictly increasing function $f: [1, 2, \ldots, k] 
 \rightarrow [1, 2, \ldots, n]$ such that for all $i \in [1, k]$, 
 $z_{i} = x_{f(i)}$.} common to both sequences.
 %
 Let $X = x_{1} x_{2} \ldots x_{n_{X}}$
 and $Y = y_{1} y_{2} \ldots y_{n_{Y}}$ be two given sequences, and
 let $\m{L}[i, j]$ $(0 \leq i \leq n_{X}, 0 \leq j \leq n_{Y})$ be the length
 of an LCS of  $x_{1} x_{2} \ldots x_{i}$ and $y_{1} y_{2} \ldots y_{j}$.
 Then ${\m{L}}[n_{X}, n_{Y}]$ is the length of an LCS of $X$ and $Y$, and
 can be computed using the following recurrence (see, e.g.,
 \cite{CormenLeRi+09}).

 \vspace{-0.3cm}
 \begin{equation}
 \m{L}(i, j) = \left\{ \begin{array}{@{}l@{~}l@{}}
                   0 & \textrm{if $i = 0 \vee j = 0$,}\\
                   \m{L}(i - 1, j - 1) + 1
                     & \textrm{if $i \in [1, n_X] \wedge j \in [1, n_Y] \wedge x_{i} = y_{j}$,}\\
                   \max\left\{\begin{array}{@{}c@{}} \m{L}(i, j - 1),\\ \m{L}(i - 1, j) \end{array}\right\}
                     & \textrm{if $i \in [1, n_X] \wedge j \in [1, n_Y] \wedge x_{i} \neq y_{j}$.}
                   \end{array} \right.
 \label{eq:dp-lcs}
 \end{equation} 

% In this section we will consider the problem of computing
% ${\m{L}}[n_{X}, n_{Y}]$ only. 
% 
 One typically solves recurrence
 \ref{eq:dp-lcs} either in row-major or in column-major order.
 However, since each $\m{L}[i, j]$ $(i, j > 0)$ depends 
 on both $\m{L}[i, j - 1]$ (on the same row) and $\m{L}[i - 1, j]$
 (same column) neither approach is suitable for Pochoir based 
 parallel computation of the $\m{L}[i, j]$ values 
 (see Figure \ref{fig:lcs-trans}(a)). An alternate approach
 is to compute diagonal by diagonal from the bottom-left
 to the top-right corner. Since no entries on any given diagonal
 depends on other entries of the same diagonal
 (see Figure \ref{fig:lcs-trans}(b)) this approach can be
 easily adapted for use with Pochoir. We first
 rotate $\m{L}$ by $45^{\circ}$ in the anti-clockwise
 direction (Figure \ref{fig:lcs-trans}(b)) and then
 slide the diagonals to the right as in Figure \ref{fig:lcs-trans}(c).
 The resulting grid (say, $L$) is a 1D stencil
 of width $n_Y + 1$ (space dimension)
 and height $n_X + n_Y + 1$ (time dimension)
 of which only a diamond shaped region
 (the cells with black boundary in Figure
 \ref{fig:lcs-trans}(c)) correspond to
 the cells of $\m{L}$. The entries in 
 that region can be computed using
 the following recurrence (where $t_j = t - j$).

 \vspace{-0.3cm}
 \begin{equation}
 L(t, j) = \left\{ \begin{array}{@{}l@{~}l@{}}
                   0 & \textrm{if $t_j = 0 \vee j = 0$,}\\
                   L(t - 2, j - 1) + 1
                     & \textrm{if $t_j \in [1, n_X], j \in [1, n_Y], x_{t_j} = y_{j}$,}\\
                   \max\left\{\begin{array}{@{}c@{}} L(t - 1, j - 1),\\ L(t - 1, j) \end{array}\right\}
                     & \textrm{if $t_j \in [1, n_X], j \in [1, n_Y], x_{t_j} \neq y_{j}$.}
                   \end{array} \right.
 \label{eq:stencil-lcs}
 \end{equation} 

 Observe that $L(t, j) = \m{L}(i, j)$ for 
 $i \in [0, n_X]$, $j \in [0, n_Y]$ and $t = i + j$.
 Thus $\m{L}(n_X, n_Y) = L(n_X + n_Y, n_Y)$.
 Pochoir code for computing $L(n_X + n_Y, n_Y)$
 is given in Figure \ref{fig:lcs}.




\subsection{Pairwise sequence alignment (PSA)}

\punt{
\racnote{PSA: 1D stencil (through transformation) with 3 integer fields}
\racnote{PSA: I have implemented both array of structures and structure of arrays
 versions of PSA. The array of structures version does not seem to work properly yet
 because of some possible bug in the Pochoir compiler (assignments to the fields
 of the structures do not seem to work). However, the array of structures version
 seem to create fewer iterators, and run faster than the strcuture of arrays version.}
}

 Given two sequences $X = x_{1}x_{2} \ldots x_{n_X}$ and
 $Y = y_{1}y_{2} \ldots y_{n_Y}$ 
% over a finite alphabet $\Sigma$,
 an {\em alignment} of $X$ and $Y$ is a matching $M$
 of the sets $\{1, 2, \ldots, n_X \}$ and $\{1, 2, \ldots, n_Y \}$
 such that $\left( ( i, j ) \in M \wedge ( i', j') \in M
 \wedge i < i' \right) \Rightarrow \left( j < j' \right)$ 
 \cite{KleinbergTa05}. A letter $x_i$ of $X$ is said to be
 in a {\em gap} provided $(i, j) \notin M$ for all $j$.
 Similarly for the letters of $Y$.
 Given a {\em gap penalty} $g$ and a mismatch cost $m$,
% for each pair $a, b \in \Sigma$,
 the {\em basic (global) pairwise sequence alignment
 problem} asks for a matching $M_{opt}$ for which
 $\left( n_X + n_Y - | M_{opt} | \right) \times g + 
 \left( \sum_{(i, j) \in M_{opt} \wedge x_i \neq y_j}{ m } \right)$ 
 is minimized \cite{KleinbergTa05}.
%
% The formulation of the basic sequence alignment problem
% favors a large number of small gaps while
% real biological processes favor the opposite.  
 Biologically more realistic alignments use 
 an {\em affine gap penalty} \cite{Gotoh82,AltschulEr86} 
 which has two parameters: a {\em gap introduction cost}
 $g_{i}$ and a {\em gap extension cost} $g_{e}$. A run of
 $k$ gaps incurs a total cost of $g_{i} + g_{e} \times k$.

 In \cite{Gotoh82} Gotoh presented a quadratic time 
 sequential algorithm for solving
 the global pairwise alignment problem with affine gap costs.
%
%
\punt{
 Gotoh's algorithm solves the following DP recurrences.
 \racnote{I think we do not need to include recurrences 
 \ref{eq:dp-pa-D}-\ref{eq:dp-pa-G} in the paper. We 
 only need to mention that there are three recurrences,
 and their combined access pattern is similar to
 that of the LCS recurrence.}

 \vspace{-0.3cm}
 \begin{equation}
\label{eq:dp-pa-D}
 D( i, j ) = \left\{ \begin{array}{@{}ll@{}}
                   G( 0, j ) + g_{e} & \textrm{if $i = 0 \land j > 0$,}\\
                   \min{\left\{\begin{array}{@{}c@{}} D( i - 1, j ),\\ G( i - 1, j ) + g_{i} \end{array}\right\} } + g_{e}
                     & \textrm{if $i > 0 \land j > 0$.}
                   \end{array} \right.
 \end{equation}

 \vspace{-0.2cm}
 \begin{equation}
 \label{eq:dp-pa-I}
 I( i, j ) = \left\{ \begin{array}{@{}ll@{}}
                   G( i, 0 ) + g_{e} & \textrm{if $i > 0 \land j = 0$,}\\
                   \min{\left\{\begin{array}{@{}c@{}} I( i, j - 1 ),\\ G( i, j - 1 ) + g_{i} \end{array}\right\} } + g_{e}
                     & \textrm{if $i > 0 \land j > 0$.}
                   \end{array} \right.
 \end{equation}

 \vspace{-0.2cm}
 \begin{equation}
\label{eq:dp-pa-G}
 G( i, j ) = \left\{ \begin{array}{@{}ll@{}}
                   0 & \textrm{if $i = 0 \land j = 0$,}\\
                   g_{i} + g_{e} \times j & \textrm{if $i = 0 \land j > 0$,}\\
                   g_{i} + g_{e} \times i & \textrm{if $i > 0 \land j = 0$,}\\
                   \min{\left\{\begin{array}{@{}c@{}} D( i, j ), I( i, j ),\\
                                   G( i - 1, j - 1 ) ) 
                              \end{array}\right\}}~
                     & \textrm{if $i > 0 \land j > 0 \land x_i = y_j$,}\\
                   \min{\left\{\begin{array}{@{}c@{}} D( i, j ), I( i, j ),\\
                                   G( i - 1, j - 1 )\\ + m ) 
                              \end{array}\right\}}~
                     & \textrm{if $i > 0 \land j > 0 \land x_i \neq y_j$.}
                   \end{array} \right.
 \end{equation}
 \vspace{-0.2cm}

 The optimal alignment cost is given by 
 $\min{\{ G( n_X, n_Y ), D( n_X, n_Y ), I( n_X, n_Y ) \}}$.
}
% punt ends
%
 Gotoh's algorithm solves three inter-dependent
 recurrences
% Observe that though there are three recurrences,
% their 
 the combined access pattern 
 of these recurrences is similar to that
 of the LCS Recurrence \ref{eq:dp-lcs}, and the
 same transformation (as described in Section
 \ref{sec:lcs} and Figure \ref{fig:lcs-trans})
 can be applied to transform them into a 
% parallelizable
 stencil computation.

\punt{
 The resulting Pochoir code is given
 in Figure \ref{fig:psa}.

\begin{figure}[ht!]
\begin{center-code}
\begin{cilk-listing}
//
// Inputs: X and Y = sequences of lengths
//                   nX and nY, respectively
//         goCost = gap open cost
//         geCost = gap extension cost
//         mmCost = mismatch cost 
//
// Output: minimum cost of a pairwise 
//         alignment of X and Y
//
int PSA( int nX, char *X, int nY, char *Y, 
         int goCost, int geCost, int mmCost )
{
   Pochoir< int, 1, 3 > psa;    
   Pochoir_Array< int, 1, 3 > G( nY + 1 ), 
                              D( nY + 1 ), 
                              I( nY + 1 );
   Pochoir_Shape< 1 > psa_shape[] 
      = { {2, 0}, {1, 0}, {0, -1}, {1, -1} };    

   G( 0, 0 ) = G( 1, 0 ) = G( 1, 1 ) = 0;
    
   Pochoir_kernel_1D( psa_fn, t, j )
      
    int i = t + 2 - j, m;

    if ( ( i >= 0 ) && ( i <= nX ) )
      {                      
       if ( ( i > 0 ) && ( j > 0 ) )
         {
           m = (X[ i ]==Y[ j ]) ? 0 : mmCost;

           D(t + 2, j) = min(D(t + 1, j), 
                    G(t + 1, j) + goCost) 
                    + geCost;
           I(t + 2, j) = min(I(t + 1, j - 1), 
                    G(t + 1, j - 1) + goCost) 
                    + geCost;                
           G(t + 2, j) = min(D(t + 2, j), 
                             I(t + 2, j), 
                             G(t, j - 1) + m);
         }  
       else
         {
           m = goCost + ( i + j ) * geCost;
               
           G( t + 2, j ) = m++;                                                     
           if ( !i ) D( t + 2, j ) = m;                
           if ( !j ) I( t + 2, j ) = m;                                
         }
      }
                      	      
   Pochoir_kernel_end

   psa.registerShape( psa_shape );
   psa.registerArray( G );
   psa.registerArray( D );
   psa.registerArray( I );            
    
   int t = nX + nY - 1;

   psa.run( t, psa_fn );
    
   return min( G( t + 1, nY ), D( t + 1, nY ), 
               I( t + 1, nY ) );
}
\end{cilk-listing}%
\end{center-code}%
\caption{Pochoir based C++ code for computing the minimum cost of a pairwise 
alignment of two sequences using Gotoh's algorithm.}
\label{fig:psa}
\end{figure}

}
% punt ends


\subsection{RNA Secondary Structure Prediction with Simple Pseudoknots}

\punt{
\racnote{RNA: 2D stencil (through transformation) with 5 integer fields; executed
 $n - 2$ times with different initial values where $n$ is the length of the RNA strand.}
\racnote{RNA: I have implemented both array of structures and structure of arrays
 versions. The array of structures version does not work yet
 because of some problem with assignments (to structure fields) in the Pochoir compiler. 
 The array of structures version seem to run faster though,
 and it creates fewer iterators compared to the strcuture of arrays version.}
}

 A single-stranded RNA can be viewed as a string
 over the alphabet $\{ A, U, G, C \}$ of bases, 
 and gives rise to {\em secondary structures} by forming 
 {\em complementary base pairs} with itself. 
 In its simplest form an RNA secondary structure
 is a planar graph with a nesting condition that
 prevents it from giving rise to so called
 'pseudoknots' \cite{Waterman95,RivasEd99,Akutsu00},
 and such a structure with the maximum number
 of base pairs can be determined in $\Oh{n^3}$ time,
 where $n$ is the length of the RNA strand.
 %
 In \cite{Akutsu00} Akutsu presented a DP
 to compute RNA secondary structures with the maximum number of
 base pairs in the presence of {\em simple pseudoknots} (see
 \cite{Akutsu00} for definition) which runs in $\Oh{n^{4}}$ time
 and uses $\Oh{n^{3}}$ space. The space complexity was
 reduced to $\Oh{n^{2}}$ in \cite{ChowdhuryLeRa10}.

 For every $i_0 \in [1, n - 2]$, Akutsu's algorithm uses a set of 5
 recurrences (see \cite{ChowdhuryLeRa10}) to compute the maximum
 number of base pairs in a simple pseudoknot with endpoints at the
 $i_{0}$-th and the $k_{0}$-th residues for all $k_0 \in [i_0 + 2,
 n]$. The recurrences solve a 3D DP with 5 fields, where each cell in
 the DP grid depends on 5 adjacent cells. These dependencies are
 similar to those in the LCS Recurrence \ref{eq:dp-lcs}, and make the
 recurrences unsuitable for direct use as 
 % parallelizable
 stencils. However, following the simple technique shown in
 Figure \ref{fig:lcs-trans}, one can rotate and translate the DP grid
 in 3D in order to transform it into a parallelizable 2D stencil. For
 each $i_0$, one can then 
 % use the Pochoir code shown in Figure \ref{fig:rnai0} 
 evaluate a stencil in order to compute the required maximum
 number of base pairs for each $(i_0, k_0)$ pair. Computing the
 numbers for all possible $(i_0, k_0)$ pairs $(1 \leq i_{0} \leq k_{0}
 - 2 \leq n - 2)$ requires 
% running the Pochoir code 
 evaluating the stencil
 $n - 2$ times. One
 can then combine all these numbers in $\Oh{n^3}$ time and $\Oh{n^2}$
 space (see \cite{ChowdhuryLeRa10}) in order
 to compute the maximum number of base pairs in a secondary structure
 that allows simple pseudoknots.

\punt{
\begin{figure}[ht!]
%\begin{minipage}{21pc}
\begin{center}%
 \mbox{\includegraphics[clip,width=0.35\textwidth]{figures/lbm.eps}}%
 \caption{The 19-point 3D stencil for LBM flow simulation. Particles
 are taken from the solid black lattice point and distributed to
 the 18 neighboring solid gray lattice points. }%
 \label{fig:lbm}%
\end{center}%
%\end{minipage}
\end{figure}%
}

\punt{
\racnote{RNA: I think Figure \ref{fig:rna} can be removed keeping
only Figure \ref{fig:rnai0}. Figure \ref{fig:rnai0}
should be simplified by replacing the optimzations
for conditional jumps with {\tt if} statements.
Comments should be added.}
}

\punt{

\begin{figure}[ht]
\begin{center-code}
\begin{cilk-listing}
typedef struct
{
   int SL, SR, SM, SMAX, SP;
} NODE;

//
// Inputs: X = RNA sequence of length nX
//
// Output: maximum number of base pairs
//         in a secondary structure 
//         (with simple pseudoknots) of X
//
int RNA( int nX, char *X )
{
   int S[ nX + 2 ][ nX + 2 ];

   for ( int i = 1; i < nX + 2; i++ )
     cilk_for ( int j = 0; j <= i; j++ )
        S[ i ][ j ] = 0;

   Pochoir_Array<NODE, 2, 3> R(nX+1, nX+1);
     
   for ( int i_0 = 1; i_0 <= 1; ++i_0 )
     {
       /* update R using stencils */
       RNAi0( nX, X, i_0, R );

       int v = -INF;
      
       for ( int k_0 = 1; k_0 <= nX; ++k_0 )
         {
          for (int i = i_0; i < k_0-1; ++i)
             v = max(NODE(R(0,i,k_0)).SP, v);
            
          NODE(R(0, i_0, k_0)).SP = v; 
         } 
            
       for (int k_0 = 0; k_0 < i_0+2; ++k_0 )
          NODE(R(1, i_0, k_0)).SP = -INF;
                    
       for (int k_0 = i_0+2; k_0 <= nX; ++k_0)
          NODE(R(1, i_0, k_0)).SP = 
            max(NODE(R(1, i_0, k_0-1)).SP, 
                NODE(R(0, i_0, k_0)).SP );            
     }
          
   for ( int i = nX; i >= 1; --i )
     for ( int j = i + 1; j <= nX; ++j )
       {
         int v;
          
         if ( base_pair( X[ i ], X[ j ] ) ) 
              v = 1 + S[ i + 1 ][ j - 1 ];
         else v = -INF;
          
         v = max( v, NODE(R( 1, i, j ) ).SP );
          
         for ( int k = i + 1; k <= j; k++ )
           v = max( v, S[ i ][ k - 1 ] 
                     + S[ k ][ j ] );
            
         S[ i ][ j ] = v; 
       }

   return S[ 1 ][ nX ];
}
\end{cilk-listing}%
\end{center-code}%
\caption{Pochoir based C++ code for computing the maximum number
of base pairs in a secondary structure (with simple pseudoknots) 
of a given RNA sequence using Akutsu's algorithm {\bf(continued
to Figure \ref{fig:rnai0})}.}
\label{fig:rna}
\end{figure}

\begin{figure}[ht]
\begin{center-code}
\begin{cilk-listing}
// Inputs: X = sequence of length nX
//         i_0 = starting index of
//               pseudoknot substructure 
// Output: The SP fields of R are updated
//         with max #base pairs in pseudoknot
//         with endpoints i_0 and k_0 > i_0
//
void RNAi0( int nX, char *X, int i_0, 
            Pochoir_Array< NODE, 2, 3 > &R )
{
   Pochoir< NODE, 2, 3 > rna;    
   Pochoir_Shape< 2 > rna_shape[] 
    = { {2, 0, 0}, {1, 0, 0}, {1, 0, -1}, 
        {1, -1, 0}, {0, -1, 0}, {0, 0, -1} };    

   /* Init R (omitted for lack of space) */

   Pochoir_kernel_2D( rna_fn, t, i, k )
      
    int j = t + 2 - i - k, jj = nX - j + 1;

    if ( (j >= 0) && (j <= nX) && (i < jj) )
      {                   
       if ( (i_0 - 1 < i) && (jj + 1 < k) )
         {
	  int sr = NODE(R(t+1, i, k-1)).SR, 
              smr = NODE(R(t+1, i, k-1)).SM,
	      sl = NODE(R(t+1, i-1, k)).SL, 
              sml = NODE(R(t+1, i-1, k)).SM,
	      smax = NODE(R(t+1, i, k)).SMAX;
	       	       	      
          NODE(R(t+2, i, k)).SM 
             = max(sr, smr, sl, sml, smax);  
          NODE(R(t+2, i, k)).SL = sl 
             = base_pair(X[ i ], X[ jj ]) ? 
              (1+NODE(R(t,i-1,k)).SMAX):-INF;                       
          NODE(R(t+2, i, k)).SR = sr 
             = base_pair(X[ jj ], X[ k ]) ? 
              (1+NODE(R(t,i,k-1)).SMAX):-INF;                             
          NODE(R(t+2, i, k)).SMAX = smax 
             = max(sl,sr,NODE(R(t+2,i,k)).SM);                                                
          NODE(R(0, i, k)).SP 
            = max(smax, NODE(R(0, i, k)).SP);
         }       
       else if ( (i_0 - 1 <= i) && (jj <= k) )
         {                   
          int sl, sr, sm = 0;
                   
          bool b0 = (i_0-1==i) && (k<=jj+1);                   
          sl = sr = b0 ? 0 : -INF;
          b0 = base_pair(X[ i ], X[ jj ]);           
          bool b1 = (jj==k), b2 = ~b1 && b0;
          b1 = b1 && b0;
          b2 = b2 && ((i_0-1<i)||(jj+1!=k));
                   
          NODE(R(t+2,i,k)).SL = sl = b1 ? 1 : 
          (b2 ? (1+NODE(R(t,i-1,k)).SMAX):sl);
                                              
          b0 = base_pair( X[ jj ], X[ k ] );
          b1 = ( i_0 - 1 == i );
          b2 = ( jj + 1 <= k - 1 );                           
          bool b3 =(b1&&(jj+1==k))||~(b1||b2);
          b3 = b3 && b0; b2 = b2 && b1 && b0;        
                                  
          NODE(R(t+2,i,k)).SR = sr = b3 ? 1 : 
          (b2 ? (1+NODE(R(t,i,k-1)).SMAX):sr);     
                             
          if ( i > i_0 - 1 ) 
           {
            int v1 = -INF, v2 = -INF;               
            if ( jj < k ) 
              v1 = max(NODE(R(t+1,i,k-1)).SR, 
                       NODE(R(t+1,i,k-1)).SM, 
                       NODE(R(t+1,i,k)).SMAX);               
            if ( i - 1 < jj ) 
              v2 = max(NODE(R(t+1,i-1,k)).SL, 
                       NODE(R(t+1,i-1,k)).SM;               
            sm = max( v1, v2 );  
           }

          int smax = max( sl, sr, sm );                  
          int sp = NODE(R(0, i, k )).SP;
          b0 = ( i_0 <= i ) && ( jj < k );                     
  
          NODE(R(t + 2, i, k)).SM = sm;                                            
          NODE(R(t + 2, i, k)).SMAX = smax;       
          NODE(R(0, i, k )).SP = b0 ? 
                      max( smax, sp ) : -INF;
         }
      }                      	      
    Pochoir_kernel_end

    rna.registerShape( rna_shape );
    rna.registerArray( R );
    rna.run( 3 * nX - 1, rna_fn );
}
\end{cilk-listing}%
\end{center-code}%
\caption{{\bf(Continued from Figure \ref{fig:rna})} Pochoir 
based C++ code for computing the maximum number of
base pairs in a simple pseudoknot structure
that starts at residue $i\_{0}$ of the
given RNA sequence.}
\label{fig:rnai0}
\end{figure}
}
% punt ends

\subsection{Lattice boltzmann method (LBM)}

The Lattice Boltzmann Method (LBM) is considered a powerful alternative
to conventional approaches in computational fluid dynamics (CFD) for
solving incompressible fluid flows based on Naviar-Stokes equations
\cite{QianHuLa92,BenziSuVe92,ChenDo03}. It is basically an explicit
finite difference approximation of discrete velocity Boltzmann
equation \cite{PlatkowskiIl88}, where each cell in a uniform 3D grid
is updated in each time step using information from a subset of
neighboring cells. Each cell represents a volume element 
of the fluid, and consists of a collection of fluid particles. The motion 
of these particles is described by a set of particle distribution functions
(PDF) in the corresponding cell. Each time step consists of two phases:
the streaming/propagation phase and the collision phase. In the streaming
phase particles from each cell move to neighboring cells based on the
PDF's in the source cell, and in the collision phase particles in
the destination cells collide with other particles streaming into
the cell from various directions and the PDF's are updated. For each 
discrete microscopic velocity $\vec{e}_{\alpha}$ a PDF $f_{\alpha}$ is defined, 
where $f_{\alpha}(\vec{x}, t)$ represents the fraction of particles with 
velocity $\vec{e}_{\alpha}$ among all particles in the cell located at 
$\vec{x}$ at time step $t$. The evolution of $f_{\alpha}$'s is often 
described by the following equation \cite{MeiShYu00}:

 \vspace{-0.3cm}
 \begin{equation}
 {\tilde{f}}_{\alpha}( \vec{x} + \vec{e}_{\alpha} \cdot \delta t, t + \delta t )
  = f_{\alpha}( \vec{x}, t ) - \frac{1}{\tau}{\left[ f_{\alpha}( \vec{x}, t ) 
  - f^{(0)}_{\alpha}( \vec{x}, t ) \right]},
 \label{eq:lbm}
 \end{equation} 
 
\noindent
where, $f^{(0)}_{\alpha}$ is the equilibrium distribution function for
$\vec{e}_{\alpha}$, and $\tau$ is the relaxation time which deteremines
the rate of approach to the equilibrium. 

We have implemented 3D LBM with 19 discrete microscopic velocity
values (including the zero velocity) and 19 PDF's per cell 
(see \cite{MeiShYu00} for details).
% The resulting 19-point stencil is shown in Figure \ref{fig:lbm}.
LBM stencils with 15 and 27 points have also been used
in literature, but the 19-point stencil provides a good
tradeoff between stability and running time \cite{MeiShYu00}.
We have implemented the stream-collide method of propagation by 
first moving the particles from current cell to neighboring cells and 
then colliding, as opposed to the collide-stream method, 
where one first collides the particles in the current cell
and then moves them to neighboring cells. 

