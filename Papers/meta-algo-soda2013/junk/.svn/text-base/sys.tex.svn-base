\secput{sys}{The Pochoir system}

This section briefly describes the structure of the Pochoir system, and the Pochoir guarantee. The Pochoir guarantee is a novel compilation strategy that makes it possible that the stencil computation specified in Pochoir language can be both directly executable for checking functional correctness in any standard {C++} tool chain in a first run (albeit much slower) and gaining huge performance improvement without any user's manual annotation or compiler specific pragma in a second run.

\begin{figure*}[!ht]
\centering
\subfigure[Executable Spec. compiled for serial loops]{\includegraphics[clip,scale=0.35]{figures/ExecSpec_loops.eps}
\label{fig:execSpec-loops}}
\subfigure[Executable Spec. compiled for optimized cache-oblivious executable]{\includegraphics[clip,scale=0.35]{figures/ExecSpec_opt.eps}
\label{fig:execSpec-opt}}
\caption{The way a user written executable specification compiled for serial loops, which can be used for checking functional correctness, and later processed by Pochoir compiler to generate highly optimized cache-efficient executables.}
\label{fig:execSpec}
\end{figure*}

The Pochoir system has two components --- the Pochoir template library and the Pochoir compiler. The Pochoir template library is a {C++} template library that implements an interface to all Pochoir language constructs (see \secref{spec}). Users can specify the data structures used in stencil computation, dimensionalities of spatial grids, as template parameters to the Pochoir library. All these template parameters will be decided at compile-time by any standard {C++} compiler. Thanks to the {C++}'s capability of template meta-programming, these template parameters will also be expanded to some application specific optimizations at compile-time. Besides the properties specified via template parameters, the computing kernel and boundary condition of a stencil computation are specified via a wrapped function, which is implemented as a lambda function in {C++0x}. The lambda function of computing kernel will be passed freely through the domain decomposition algorithm function and called when reaching the base case. The lambda function of boundary function will be stored at the underlying storage class and invoked when some memory access is detected to exceed the boundary of computing domain. Another benefit of using lambda function is that it can easily capture any identifiers that can be accessed at the point of lambda function definition \footnote{commonly called closure} and pass them along with it to any other points in the library.

The Pochoir compiler is employed to do base case optimization and boundary optimization. The distinction between template library and compiler is that the job of template library is to do something common across different computing kernel and different boundary conditions, while that of compiler is to do application specific optimization. No matter what computing kernel or boundary function users will specify in Pochoir, the underlying divide-and-conquer strategy for decomposing the computing domain is similar. They are only different in user's data structure, dimensionality of spatial grid, which can be supplied as template parameters. That's why the domain decomposition algorithm is programmed in Pochoir template library. While the optimization of the base case includes code cloning of original kernel, constructing and transforming Abstract Syntax Tree (AST), etc. which is a more appropriate job for compiler.

The typical execution procedure of stencil computation in Pochoir has two ($2$) runs. In the first run, the programmer can compile the stencil specifiction in Pochoir with the Pochoir template library, but without Pochoir compiler. That is, he / she can compile it by a standard {C++} compiler with the Pochoir template library (see \figref{execSpec-loops}). The point of this first run is not performance, but functional correctness. In current Pochoir template library implementations, if it's compiled without Pochoir compiler, by default, the library will connect the user's specification to a serial loop based stencil computing algorithm. This serial loop algorithm offers additional checking of memory footprint of the stencil to make sure it matches the registered ``Pochoir\_Shape'' (see \secref{spec}).

After the first run, to obtain high performance, the programmer then runs the source through the Pochoir compiler, which acts as a preprocessor to the Intel compiler, performing a source-to-source translation into a \defn{postsource} program in the base language.  The postsource is then compiled with the Intel compiler to produce the optimized binary executable (see \figref{execSpec-opt}). The Pochoir compiler makes the following promise:

\begin{quote}
  \textbf{The Pochoir Guarantee:} If the stencil program compiles and
  runs with the Pochoir template library, no errors will occur when it
  is compiled with the Pochoir compiler or during the subsequent
  running of the optimized binary.
\end{quote}

This novel compilation strategy allowed us to build significant domain-specific optimizations into the Pochoir compiler without taking on the massive job of parsing and type-checking C++ code.  Knowing that the source program compiles error-free with the Pochoir template library allows the Pochoir compiler to treat portions of the source as uninterpreted text, confident that the Intel compiler will compile it correctly in the optimized postsource.  Moreover, the Pochoir template library allows the programmer to debug his or her code using a comfortable native C++ tool chain without the complications of the Pochoir compiler.
