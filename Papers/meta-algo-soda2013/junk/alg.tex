% -*- Mode: Latex -*-
\secput{alg}{Pochoir's cache-oblivious algorithm}

\newtheorem{mydef}{Definition}

This section describes the parallel algorithm \proc{Trap} at the core
of Pochoir's efficiency.  \proc{Trap} is a cache-oblivious algorithm
based on ``trapezoidal decompositions'' \cite{FrigoSt05, FrigoSt09},
but which employs a novel ``hyperspace-cut'' strategy to
improve parallelism without sacrificing cache-efficiency.
On a $d$-dimensional spatial grid with all spatial dimensions
roughly equal to the time dimension $h$, \proc{Trap}
achieves $\Th{ h^{ d + 1 - \lg{ \left( d + 2 \right) } } / d }$ parallelism
while the original parallel trapezoidal decomposition
algorithm in \cite{FrigoSt09} reaches only
$\Th{ h^{ d + 1 - \lg{ \left( 2^d + 1 \right) } } } = \Oh{ h }$
parallelism under the same asymptotic cache complexity.
\celnote{Give bounds.}

\proc{Trap} uses a cache-oblivious \cite{FrigoLePr99}
divide-and-conquer strategy based on recursive trapezoidal
decomposition of the space-time grid which was introduced by Frigo and
Strumpen in \cite{FrigoSt05}. They used the technique for sequential
evaluation of arbitrary stencils on multidimensional spatial grids
which was later parallelized in \cite{FrigoSt09}. However, \proc{Trap}
differs from that parallel stencil algorithm 
in the way the spatial dimensions are cut
during recursive decomposition of the space-time grid.
%
While the algorithm in \cite{FrigoSt09} cuts the spatial dimensions
one at a time, \proc{Trap} performs a 
\defn{hyperspace cut}, that is, it
simultaneously cuts as many
dimensions as possible which allows it to evaluate
the resulting subtrapezoids in fewer parallel steps. 
%
However, as we will argue later in this section
\proc{Trap} is able to achieve this improvement
in its parallel running time within the same 
cache complexity as Frigo and Strumpen's original
parallel algorithm.

\proc{Trap} operates as follows.  \Liref{canCut} of \figref{trap-code}
determines whether any spatial dimension can be cut.  If so,
\lirefs{cutX}{cutY} make a hyperspace cut by assigning \celnote{need to explain what a hyperspace cut is. it's explained below in a parenthetical -bradley}
different dependency levels, as we describe below and in
\figref{dep-level}, to different subtrapezoids.
\Lirefs{parallelSpawnBegin}{parallelSpawnEnd} recursively walk all
subtrapezoids level by level in parallel.
\Lirefs{simTimeCutBegin}{simTimeCutEnd} perform a time cut if no space
cut can be performed. \Lirefs{simBaseCaseBegin}{simBaseCaseEnd} do the
base-case computation if the trapezoid is sufficiently small that no
space or time cut is productive.

\punt{
\begin{figure}
\begin{minipage}{21pc}
\subfigure[Space-Cut Parallel Stencil Algorithm \cite{FrigoSt05,FrigoSt09}]
{\begin{minipage}{\textwidth} \begin{codebox}
\Procname{$\proc{trap\_seq}(t_0, t_1, grid)$}
\li $\Delta t \gets t_1 - t_0$
\li \For $i \gets 0$ \To $d$
\li   \Do \If $(grid.x_1[i] - grid.x_0[i] \geq 2 \times (2 \times \sigma[i] \times \Delta t)$
\li     \Then \Comment cut into spatial dimension $i$
\li       \Parfor $i \gets 0$ \To $r$ \Comment black subtrapezoids
\li         \Do \proc{trap\_seq}($t_0$, $t_1$, black subtrapezoid);
          \End
\li       \Parfor $i \gets 0$ \To $r+1$ \Comment gray subtrapezoids
\li         \Do \proc{trap\_seq}($t_0$, $t_1$, gray subtrapezoid);
          \End
\li \Return
        \End
    \End
\li \If $(\Delta t > 1)$ \Comment time cut
\li     \Then $\delta t \gets \Delta t / 2$
\li     \proc{trap\_seq}($t_0$, $t_0 + \delta t$, bottom subtrapezoid)
\li     \proc{trap\_seq}($t_0 + \delta t$, $t_1$, top subtrapezoid)
\li \Else \Comment base case
\li     \func{kernel}$(t_0, t_1, grid)$
	\End
\end{codebox}
\vspace{0.1cm}
\end{minipage}
\label{fig:naiveDDcode}}
\end{minipage}
%
\begin{minipage}{18pc}
\centering
\subfigure[$1$D Time Cut]{\includegraphics[clip,scale=0.5]{figures/1D_Time_Cut.eps}
\label{fig:1DTimeCut}}
\subfigure[$1$D Parallel Space Cut]{\includegraphics[clip,scale=0.5]{figures/1D_Parallel_Cut.eps}
\label{fig:1DParallelCut}}
\end{minipage}

\caption{\subref{fig:naiveDDcode} A space-cut extension of cache-oblivious arbitrary
  $d$-dimensional parallel stencil algorithm from
  \cite{FrigoSt09}. $d$ is the number of spatial dimensions. $grid$
  is the data structure holds all the properties that defines a
  spatial grid: $x_0[i]$ and $x_1[i]$ is the begining and end point of
  that spatial grid on spatial dimension $i$, respectively. $dx_0[i]$
  and $dx_1[i]$ are the slope of trapezoid 
  at points $x_0[i]$ and $x_1[i]$, respectively. 
  $\sigma [i]$ is the slope of stencil on spatial dimension $i$
  A trapezoid is black
  on spatial dimension $i$ means that the slope on that
  dimension has the property: $dx_0[i] \geq 0$ and $dx_1[i] \leq 0$. A
  trapezoid is
  gray on spatial dimension $i$ means that the slope on that
  dimension has the property: $dx_0[i] < 0$ or $dx_1[i] >
  0$. \func{kernel} is a specific computing kernel.
  \subref{fig:1DTimeCut} \& \subref{fig:1DParallelCut} $1$D Divide-and-conquer, 
  both in time dimension and spatial dimension.}
\label{fig:SeqCut}

\end{figure}
}

\punt{
\begin{figure}[t!]
\begin{minipage}{21pc}
\subfigure[Space-Cut Parallel Stencil Algorithm \cite{FrigoSt05,FrigoSt09}]
{\begin{minipage}{\textwidth} \begin{codebox}
\Procname{$\proc{trap\_seq}( \m{T}, \sigma, r )$}
\li $h \gets \m{T}.t_1 - \m{T}.t_0$;~~ $d \gets \textrm{spatial dimension of}~\m{T}$
\li \For $i \gets 0$ \To $d$
\li   \Do \If $(\m{T}.x_1[i] - \m{T}.x_0[i] \geq 2 \times \sigma[ i ] \times r \times h)$
      \Then 
\li       Cut $\m{T}$ along spatial dimension $i$
\li       Let $\m{T}_i^{black}$ (resp. $\m{T}_i^{gray}$) be a subtrapezoid 
\zi       of $\m{T}$ with a black (resp. gray) 
\zi       subtrapezoid along spatial dimension $i$ 
\li       \Parfor $i \gets 0$ \To $r$ \Comment spawn all $\m{T}_i^{black}$'s
\li         \Do \proc{trap\_seq}($\m{T}_i^{black}$, $\sigma$, $r$);
          \End
\li       \Parfor $i \gets 0$ \To $r+1$ \Comment spawn all $\m{T}_i^{gray}$'s
\li         \Do \proc{trap\_seq}($\m{T}_i^{gray}$, $\sigma$, $r$);
          \End
\li \Return
        \End
    \End
\li \If $(h > 1)$ \Comment time cut
\li     \Then 
% $\delta t \gets \Delta t / 2$
        Let $\m{T}^{bottom}$ and $\m{T}^{top}$ be the bottom and top trapezoids 
\zi     of $\m{T}$ obtained by cutting $h$ in the middle
\li     \proc{trap\_seq}($\m{T}^{bottom}$, $\sigma$, $r$)
\li     \proc{trap\_seq}($\m{T}^{top}$, $\sigma$, $r$)
\li \Else \Comment base case kernel function
\li     \func{kernel}$(\m{T})$
	\End
\end{codebox}
\vspace{0.1cm}
\end{minipage}
\label{fig:naiveDDcode}}
\end{minipage}
%
\begin{minipage}{2pc}
~
\end{minipage}
%
\begin{minipage}{16pc}
\centering
\subfigure[$1$D Space Cut]{\includegraphics[clip,scale=0.5]{figures/1D_Parallel_Cut.eps}
\label{fig:1DParallelCut}}
\subfigure[$1$D Time Cut]{\includegraphics[clip,scale=0.5]{figures/1D_Time_Cut.eps}
\label{fig:1DTimeCut}}

\end{minipage}

\caption{\subref{fig:naiveDDcode} The parallel cache-oblivious stencil
  algorithm for $d$-dimensional spatial grids derived from
  \cite{FrigoSt05,FrigoSt09}. The inputs are a well-defined
  trapezoid $\m{T}$ with $d$ spatial dimensions, 
  an array $\sigma[0 \ldots d-1]$ where $\sigma [i]$ is the
  slope of the stencil along spatial dimension $i$,
  an integer $r \geq 2$ specifying the number of black subtrapezoids 
  to produce when applying space-cut on any spatial dimension. The algorithm
  applies space-cuts by cutting one spatial dimension
  at a time.
  \subref{fig:1DTimeCut} \& \subref{fig:1DParallelCut} $1$D Divide-and-conquer, 
  both in time dimension and spatial dimension.}
\label{fig:SeqCut}

\end{figure}
}
% punt ends



\punt{
\begin{figure}
\centering
\subfigure[]{\includegraphics[clip,scale=0.5]{figures/1D_Parallel_Cut.eps}
\label{fig:1DParallelCut}}
\subfigure[]{\includegraphics[clip,scale=0.5]{figures/1D_Time_Cut.eps}
\label{fig:1DTimeCut}}
%
\caption{$1$D Divide-and-conquer, 
  both in \subref{fig:1DParallelCut} spatial dimension and 
  \subref{fig:1DTimeCut} time dimension.}
\label{fig:SeqCut}
\end{figure}
}
% punt ends


\begin{figure*}
\centering
\subfigure[]{\includegraphics[clip,scale=0.4]{figures/space-cut-2.eps}
\label{fig:1DParallelCut}}
\subfigure[]{\includegraphics[clip,scale=0.4]{figures/space-cut-3.eps}
\label{fig:1DParallelCutInverted}}
\subfigure[]{\includegraphics[clip,scale=0.4]{figures/time-cut-1.eps}
\label{fig:1DTimeCut}}
%
\vspace{-0.3cm}
\caption{$1$D Divide-and-conquer, 
  both in spatial dimension (\subref{fig:1DParallelCut} \& \subref{fig:1DParallelCutInverted}) and 
  time dimension (\subref{fig:1DTimeCut}).}
\label{fig:SeqCut}
\end{figure*}

We will first introduce some notations and definitions
(mostly borrowed from \cite{FrigoSt05,FrigoSt09}) that
will be useful in describing and analyzing our algorithm.
%
A $d$-dimensional trapezoid (in fact, hypertrapezoid) $\m{T} = \paren{t_0, t_1; 
\paren{\forall{i \in [0, d)}: x_{0}[ i ], x_{1}[ i ],
dx_{0}[ i ], dx_{1}[ i ] }}$ is the set of integer tuples
$\langle t, x^{(0)}, x^{(1)}, \ldots, x^{(d - 1)}\rangle$
such that $t \in [t_0, t_1)$ and $x^{(i)} \in [~x_0[ i ] + dx_{0}[ i ](t - t_0),~ 
x_1[ i ] + dx_{1}[ i ](t - t_0)~)$ for all $i \in [0, d)$. 
%
The \defn{height} of $\m{T}$ is $h = t_1 - t_0$, and its
\defn{width} $w_i$ in dimension $i$ is the larger
\racnote{$w_i$ is different from \cite{FrigoSt05,FrigoSt09},
where it is defined as the average of the two parallel sides} of
the two parallel sides in that dimension.
Let $\sigma_i$ and ${\sigma'}_i$ be the two
\defn{runs} (i.e., inverse of slope) of the stencil
along spatial dimension $i$. The \defn{normalized width}
of $\m{T}$ along spatial dimension $i$ is then given by 
${\widehat{w}}_i = { w_i / { | {\sigma}_i - {\sigma'}_i | } }$.
%
We call $\m{T}$ a \defn{well-formed} (termed \defn{well-defined}
in \cite{FrigoSt05,FrigoSt09}) trapezoid
provided $h \geq 0$, and $\forall{i \in [ 0, d )}$
the following conditions hold: $x_1[i] \geq x_0[i]$
and $x_1[i] + h \times dx_1[i] \geq x_0[i] + h \times dx_0[i]$.
%
\punt{
We consider $\m{T}$ to be \defn{black} on spatial dimension $i$ provided 
$dx_0[i] \geq 0$ and $dx_1[i] \leq 0$, otherwise
it is considered \defn{gray} on that dimension.
}
% punt ends

Efficient space cuts play a key role in the improved
performance of our algorithm, and so before
describing our algorithm we briefly explain the
notion of space cuts, 
and also show that hyperspace cuts 
% (i.e., simultaneous \celnote{this parenthetical remark should be moved to an earlier use of ``hyperspace''. -Badley}
% space cuts along multiple spatial dimensions) 
can be handled very efficiently on a parallel machine.
%
A \defn{space cut} is applicable along any 
spatial dimension of a well-formed trapezoid $\m{T}$ 
provided that dimension (in 2D space-time) can be split 
into 3 well-formed subtrapezoids as shown in 
\figreftwo{1DParallelCut}{1DParallelCutInverted}. 
The gray subtrapezoid in the middle is a minimal
(triangle shaped) trapezoid, i.e., one of its bases has
length zero. The larger base of $\m{T}$ is split
in the middle, and each part forms the larger
base of a black subtrapezoid.
The two black subtrapezoids do not have
any interdependencies, and so can be evaluated
in parallel. In \figref{1DParallelCut}
the black subtrapezoids are evaluated first
followed by the gray subtrapezoid, while in case of
\figref{1DParallelCutInverted} the opposite
is done. In general,
inverted subtrapezoids depend on straight
subtrapezoids, and so
one evaluates the straight subtrapezoid(s) first
followed by the inverted one(s).
Thus the three subtrapezoids can be
evaluated in two parallel steps.

\begin{figure}
\centering

\subfigure[]{\includegraphics[clip,width=2.5in]{figures/hyperspace-cut.eps}
\label{fig:dep-level}}
\hspace{2cm}
\subfigure[]{\includegraphics[clip,scale=0.3]{figures/dep-graph.eps}
\label{fig:dep-graph}}
 \vspace{-0.3cm}
 \caption{\subref{fig:dep-level} Dependency levels of subtrapezoids 
 resulting from a hyperspace cut along both dimensions
 of a trapezoid;
 \subref{fig:dep-graph} Dependency graph of Figure \subref{fig:dep-level}.}%
 \label{fig:sim-space-cut}%
\end{figure}%


\begin{lemma}
All subtrapezoids created by a hyperspace cut 
on $k \geq 1$ of the $d \geq k$ spatial dimensions
of a $(d + 1)$-dimensional trapezoid can be evaluated 
in $k + 1$ parallel steps.
\label{lem:simParallelStepsNew}
\end{lemma}\racnote{I do not think the use of "parallel steps" is appropriate here.
What is a better term?}
%
\begin{proof}
%
Let us assume w.l.o.g. that the hyperspace cut 
is applied on the first $k$ dimensions of a given
trapezoid $\m{T}$. The hyperspace cut will slice each spatial 
dimension involved into an alternating sequence of 
3 straight and inverted trapezoids 
in 2-dimensional space-time (see \figreftwo{1DParallelCut}{1DParallelCutInverted}). 
For each spatial dimension let us number these trapezoids with 
consecutive integers starting from either 1 or 2 such
that each straight trapezoid gets an even number while
the inverted ones get odd numbers.
When such cuts are applied in all $k$ dimensions involved
a set of at most $3^{k}$ subtrapezoids
will be created in $(k + 1)$-dimensional space-time.
Let us denote this set by $S(\m{T})$.
Each $\m{T}' \in S(\m{T})$ can be identified
with a unique $k$-tuple $\langle u_0, u_1, \ldots, 
u_{k - 1} \rangle$, where $u_i$ ($0 \leq i < k$) 
is the number associated with its 2-dimensional 
trapezoidal side along spatial dimension $i$.
Let us call this $k$-tuple the \defn{coordinates}
of $\m{T}'$. Observe that an odd $u_i$ 
(i.e., $u_i ~\textrm{mod}~ 2 = 1$)
implies that $\m{T}'$ cannot be evaluated until 
all (at most 2) of its neighboring subtrapezoids 
along dimension $i$ are evaluated. An even
$u_i$, on the other hand, means that $\m{T}'$
has no dependencies along dimension $i$. 
Hence, $\sum_{i = 0}^{k - 1}{\paren{u_i ~\textrm{mod}~ 2}}$
can be used to count the number of dependencies
of $\m{T}'$ along its spatial dimensions.
Let us call this number the \defn{dependency level}
of $\m{T}'$, and denote it by $dep(\m{T}')$.
See \figref{dep-level} for an example
with $k = 2$.

We will now show that all subtrapezoids
in $S(\m{T})$ can be evaluated in $k + 1$ parallel
steps without violating their dependency
relationships. Let us build a directed graph
$G = (V, E)$ that will capture the dependency
relationships among the members of $S(\m{T})$
as follows (see \figref{dep-graph}
for an example). Each node in $G$ will correspond to
exactly one member of $S(\m{T})$ and vice versa, 
and thus $|V| = |S(\m{T})|$. Given any pair 
$\m{T}', \m{T}'' \in S(\m{T})$ with
coordinates $\langle u'_0, u'_1, \ldots, 
u'_{k - 1} \rangle$ and $\langle u''_0, u''_1, \ldots, 
u''_{k - 1} \rangle$, respectively,
there will be a directed edge from
$\m{T}'$ to $\m{T}''$ in $G$ (meaning
$\m{T}''$ directly depends on some entries
in $\m{T}'$) provided for some $i \in [0, k)$ 
the following conditions hold: 

\begin{closeitemize}

\item $u'_i ~\textrm{mod}~ 2 = 0$:
$\m{T}'$ has black trapezoidal
sides in spatial dimension $i$;
and 

\item $|u''_i - u'_i| = 1 \wedge
\forall_{j \neq i}{u''_j = u'_j}$:
$\m{T}'$ and $\m{T}''$ 
are neighbors along spatial dimension~$i$.

\end{closeitemize}

Observe that under these two conditions
$dep(\m{T}'') = dep(\m{T}') + 1$. Thus along
any chain (i.e., directed path) in $G$ the dependency
levels are strictly increasing, and no two nodes 
with the same dependency level can lie on
the same chain. As a result, all members of $S(\m{T})$ with 
the same dependency level form an antichain, and can be
evaluated simultaneously. Since there are only
$k + 1$ distinct dependency levels, all 
members of $S(\m{T})$ can be evaluated in
$k + 1$ parallel steps with step $l \in [0, k]$
evaluating all $\m{T}' \in S(\m{T})$
with $dep(\m{T}') = l$.\qed
%
\end{proof}

Now we are in a position to describe our algorithm.
Given a well-formed trapezoidal space-time grid 
$\m{T}$, \proc{Trap}
works by recursively decomposing $\m{T}$ into smaller
well-formed trapezoids as follows.
%


\paragraph{Hyperspace cut.}
%
We first count the number of dimensions of $\m{T}$ on which a 
space cut can be applied (see \figreftwo{1DParallelCut}{1DParallelCutInverted}). 
If this number is at least one
we apply a hyperspace cut involving all such dimensions
and recursively evaluate all resulting subtrapezoids
based on dependency levels as described in the proof
of \lemref{simParallelStepsNew}. 
%

\paragraph{Time cut.}
%
If a hyperspace cut is not applicable and $\m{T}$ has height
at least 2 then we cut $\m{T}$ in the
middle of its time dimension, and recursively evaluate the 
bottom half followed by the top half (see \figref{1DTimeCut}).
%

\paragraph{Base case.}
%
If neither a hyperspace cut nor a time cut can be applied,
$\m{T}$ is evaluated directly 
by calling a stencil-specific kernel function.


We analyze the parallelism using a work/span
analysis~\cite[Ch.~27]{CormenLeRi+09}.  The next theorem proves an
upper bound on the span of our hyperspace-cut algorithm assuming that
the normalized width in each spatial dimension is equal to the length
of the time dimension.

\begin{theorem}
The span of \proc{Trap} when visiting a trapezoid $\m{T}$ 
with ${\widehat{w}}_i = h, \forall{i} \in [0, d)$,
is $T_{\infty}(\m{T}) = \Th{dh^{\lg{(d + 2)}}}$, where 
$h$ is the height of $\m{T}$, and
${\widehat{w}}$ is its normalized width in the $i$-th 
spatial dimension.
\label{thm:HyperspaceCutSimpleCase}
\end{theorem}
%
%----------------------------------------------------------------------
% Try to fit this proof in by cutting elsewhere.
%\punt{
\begin{proof}
%
For simplicity we will assume that a call to 
the kernel function and a spawn cost at most one unit 
of the critical path (as in \cite{FrigoSt09}).
%
Then a hyperspace cut can be described using
the following recurrence.
%
\begin{eqnarray*}
\lefteqn{T_{\infty}(h, {\widehat{w}}_0, {\widehat{w}}_1, \ldots, {\widehat{w}}_{d - 1})}\\
& = & T_{\infty}{\left(h, {{\widehat{w}}_0 \over 2}, {{\widehat{w}}_1 \over 2}, \ldots, 
{{\widehat{w}}_{d - 1} \over 2}\right)}
+~ T_{\infty}{\left(h, h, {{\widehat{w}}_1 \over 2}, \ldots, 
{{\widehat{w}}_{d - 1} \over 2}\right)}~\\
& & +~ T_{\infty}{\left(h, h, h, \ldots, 
{{\widehat{w}}_{d - 1} \over 2}\right)}
+~ \ldots ~+~ T_{\infty}{\left(h, h, h, \ldots, h\right)}~\\
& & +~ \sum_{i = 0}^{d}{\lg{\left( \choose{d}{i} 2^i \right)}},
\end{eqnarray*}
%
where the last summation accounts for the spawns using {\tt cilk\_for}.

The recurrence for a time cut can be written
as follows.
%
\begin{eqnarray*}
\lefteqn{T_{\infty}(h, {\widehat{w}}_0, {\widehat{w}}_1, \ldots, {\widehat{w}}_{d - 1})}\\
& = & T_{\infty}{\left(\frac{h}{2}, {\widehat{w}}_0, {\widehat{w}}_1, \ldots, {\widehat{w}}_{d - 1}\right)}
+~ T_{\infty}{\left(\frac{h}{2}, {\widehat{w}}_0 - {h \over 2}, \ldots, 
{\widehat{w}}_{d - 1} - {h \over 2}\right)} + 2~\\
& = & T_{\infty}{\left(\frac{h}{2}, {\widehat{w}}_0, {\widehat{w}}_1, \ldots, {\widehat{w}}_{d - 1}\right)}
 +~ T_{\infty}{\left(\frac{h}{2}, {{\widehat{w}}_0 \over 2}, {{\widehat{w}}_1 \over 2}, \ldots, 
{{\widehat{w}}_{d - 1} \over 2}\right)} + 2
\end{eqnarray*}

Let us denote $T_{\infty}{\left(h, h, h, \ldots, h\right)}$ by
$T_{\infty}{\left(h\right)}$. Since ${\widehat{w}}_i = h$
for $0 \leq i < d$, if we apply a hyperspace cut on
the first subtrapezoid on the right hand side of the
recurrence above, we obtain the following.
%
\begin{eqnarray*}
T_{\infty}{\left(h\right)} 
& = & ( d + 2 ) T_{\infty}{\left({h \over 2}\right)}
+ 2 + \sum_{i = 0}^{d}{\lg{\left( \choose{d}{i} 2^i \right)}}~\\
& = & ( d + 2 )^{ \lg{ h } } + { { ( d + 2 )^{ \lg{ h } } - 1 } \over { d + 1 } } \left( 2 + \sum_{i = 0}^{d}{\lg{\left( \choose{d}{i} 2^i \right)}} \right)
\end{eqnarray*}

The solution to the recurrence above is given by
$\Th{d (d + 2)^{\lg{h}}} = \Th{ dh^{\lg{( d + 2)}} }$.
%
\end{proof}
%}

The following corollary follows from the observation
that when all normalized spatial dimensions are equal but
smaller than the time dimension, \proc{Trap}
performs a sequence of time cuts until the
time dimension becomes equal to the spatial dimensions,
and at that point \thmref{HyperspaceCutSimpleCase}
applies.

\begin{corollary}
The span of \proc{Trap} when visiting a trapezoid $\m{T}$ 
with ${\widehat{w}}_i = w, \forall{i} \in [0, d)$,
and $h = 2^k w$ for some integer $k \geq 0$,
is $T_{\infty}(\m{T}) = \Th{{ dh^{1 + \lg{(d + 2)}} / w}}$, where 
$h$ is the height of $\m{T}$, and
${\widehat{w}}$ is its normalized width in the $i$-th 
spatial dimension.
\label{cor:HyperspaceCutSimpleCase}
\end{corollary}



\punt{
The following theorem proves an upper bound on the
span of our hyperspace-cut algorithm assuming that widths in 
all spatial dimensions of the input spatial grid
are within constant factors of each other,
and the stencil has the same slope $1 \over \sigma$
along all spatial dimensions..
The proof has been omitted
from this extended abstract due to space constraints.


\begin{theorem}
The critical path length (i.e., span) of \proc{Trap} 
when visiting a trapezoid $\m{T}$ is $T_{\infty}(\m{T}) = 
\Oh{{\left( {\sigma} r \right)}^d h {\sum_{i = 0}^{d - 1}{ w_{i}^{\gamma}}}}$, where 
$r \geq 1 + \frac{d}{2}$, $\gamma \geq \max{\left\{ \frac{\lg{(d + 1)}}{\lg{(2r - 1)}}, 
\frac{1}{\paren{ 2 \sigma r }^d} \right\}}$, 
$h$ is the height of $\m{T}$ and $w_{i}$ is its width in the $i$-th ($0 \leq i < d$) 
spatial dimension. 
\label{thm:SimSpaceCutNew}
\end{theorem}
\racnote{this theorem assumes that $w_i$ is the average of the two parallel sides}
}
% punt ends
%
\punt{
\begin{proof}
%
For simplicity we will assume that a call to 
the kernel function and a spawn cost at most one unit 
of the critical path (as in \cite{FrigoSt09}).
We will also prove the bound for write operations
only. As each write is associated with only
a constant number of read operations, the proved
bound will continue to hold for both reads and
writes combined.

We will prove by induction on the volume of the
trapezoid that 
%
%\begin{equation}
$T_{\infty}(\m{T}) \leq 
{\left( 2 {\sigma} r \right)}^d \left( 2h {\sum_{i = 0}^{d - 1}{ w_{i}^{\gamma}}} - 1 \right)$.
%\label{eq:SeqSpaceCutBound}
%\end{equation}
%

In the base case $h = 1$, and the spatial grid is a hyperrectangle.
We cut each spatial dimension into
$k_i = \ceil{ { {w_i} \over {2 \sigma r} } }$ pieces of equal length. 
The resulting $\prod_{i = 0}^{d - 1}{k_i}$ spatial subgrids
are evaluated in parallel, and spawning these jobs using
{\tt cilk\_for} adds $\sum_{i = 0}^{d - 1}{\lg{k_i}}$ to the
span. Thus we have
%
$$T_{\infty}(h, w_0, w_1, \ldots, w_{d - 1}) \leq 
\sum_{i = 0}^{d - 1}{\lg{k_i}}
+ {\left( 2 {\sigma} r \right)}^d
\leq {\left( 2 {\sigma} r \right)}^d + \sum_{i = 0}^{d - 1}{\lg{w_i}}
\leq {\left( 2 {\sigma} r \right)}^d {\left( 2\sum_{i = 0}^{d - 1}{ w_{i}^{\gamma} } - 1\right)},$$
%
where the last step assumes that $\gamma \geq \frac{1}{\paren{ 2 \sigma r }^d}$.

If $h > 1$, the trapezoid is recursively cut 
the into strictly smaller subtrapezoids 
for which the bound holds. Either a hyperspace cut or a time cut
is applied.

If each spatial dimension is large enough 
(i.e., $w_i + \sigma h \geq 2 \sigma r h$ for $0 \leq i < d$) 
so that a spatial cut can be applied on each
of them, we apply such a hyperspace cut.
This will result in a total of $(2r + 1)^d$ spawns
on smaller subtrapezoids. However, these jobs
will be spawned in $d + 1$ parallel steps
(see \lemref{simParallelStepsNew})
with step $j \in [0, d]$ spawning 
%$C^{d}_{j} r^{d - j} (r + 1)^j$
$\comb{d}{j} r^{d - j} (r + 1)^j$
of them. Since {\tt cilk\_for} is used for the
spawns, we have
%
\begin{eqnarray*}
T_{\infty}(h, w_0, w_1, \ldots, w_{d - 1})
& \leq & (d + 1) T_{\infty}{\left(h, \frac{w_{0}}{2r - 1}, \frac{w_{1}}{2r - 1}, 
\ldots, \frac{w_{d - 1}}{2r - 1}\right)} + \sum_{j = 0}^{d}{\lg{\left( \comb{d}{j} r^{d - j} (r + 1)^j \right)}}~\\
%
& \leq & (d + 1) (2 \sigma r)^d \paren{  2 h \sum_{i = 0}^{d - 1}{\paren{ \frac{w_i}{2r - 1} }^{\gamma} } - 1 } + d(d + 1)\lg{\paren{ d( r + 1) }}~\\
%
% & \leq & (2 \sigma r)^d \paren{  2 h \sum_{i = 0}^{d - 1}{\paren{ \frac{w_i}{2r - 1} }^{\gamma} } - 1 } + d\paren{ (d + 1)\lg{\paren{ d( r + 1 ) } } - \paren{2 \sigma r}^{d} }~\\
%
& \leq & (2 \sigma r)^d \paren{  2 h \sum_{i = 0}^{d - 1}{ \frac{\paren{ d + 1 } w_i^\gamma }{\paren{ 2r - 1 }^{\gamma}} } - 1 }
  \leq (2 \sigma r)^d \paren{  2 h \sum_{i = 0}^{d - 1}{w_{i}^{\gamma} } - 1 },~\\
\end{eqnarray*}
%
where, in the last step we assume that $\gamma \geq \frac{\lg{(d + 1)}}{\lg{(2r - 1)}}$.

If we are not in the base case and a space cut cannot
be applied, we perform a time cut.
%
For a time cut, let $u_{i}$ (resp. $v_{i}$) be the width of the lower 
(resp. upper) subtrapezoid for spatial dimension $i$. Then we have,
%
\begin{eqnarray*}
T_{\infty}(h, w_0, w_1, \ldots, w_{d - 1})
& \leq & T_{\infty}{\left(\frac{h}{2}, u_0, u_1, \ldots, u_{d - 1}\right)}
+ T_{\infty}{\left(\frac{h}{2}, v_0, v_1, \ldots, v_{d - 1}\right)} + 1~\\
& \leq & {\left( 2 {\sigma} r \right)}^d \left( h {\sum_{i = 0}^{d - 1}{u_{i}^{\gamma}}} - 1 \right)
 + {\left( 2 {\sigma} r \right)}^d \left( h {\sum_{i = 0}^{d - 1}{v_{i}^{\gamma}}} - 1 \right) + 1~\\  
\end{eqnarray*}
%
Since $r \geq 1 + \frac{d}{2} \Rightarrow \gamma \leq 1$, by Jensen's inequality, 
$u_{i}^{\gamma} + v_{i}^{\gamma} \leq 2{\left( \frac{ u_{i} + v_{i} }{2} \right)}^{\gamma} 
= 2w_{i}^{\gamma}$, for $\forall{i} \in [0, d)$.
Hence,
%
\begin{eqnarray*}
T_{\infty}(h, w_0, w_1, \ldots, w_{d - 1})
& \leq & {\left( 2 {\sigma} r \right)}^d \left( 2h {\sum_{i = 0}^{d - 1}{w_{i}^{\gamma}}} - 2 \right) + 1  
 \leq  {\left( 2 {\sigma} r \right)}^d \left( 2h {\sum_{i = 0}^{d - 1}{w_{i}^{\gamma}}} - 1 \right),~\\
\end{eqnarray*}
%
and the proof is complete.

\end{proof}
}
% punt ends


Let \proc{Strap} be the version of Frigo and Strumpen's parallel stencil
algorithm \cite{FrigoSt09} that performs the space cuts
as in \figreftwo{1DParallelCut}{1DParallelCutInverted}.
%
Then the major difference between \proc{Trap}
and \proc{Strap} (as well as the original parallel
algorithm in \cite{FrigoSt09}) is in the way the space cuts 
are applied. Unlike our algorithm \proc{Strap} applies
the space cuts one at a time. Each space cut results in
one synchronization point, and hence a sequence of $k$ 
space cuts applied by \proc{Strap} introduces $2^k - 1$ synchronization 
points compared to only $k$ synchronization points generated
by \proc{Trap} (see \lemref{simParallelStepsNew}). Thus each space 
cut virtually doubles \proc{Strap}'s span.
%
\figref{dep-level} shows a simple example where \proc{Strap}
produces $2^2 - 1 = 3$ synchronization points while
\proc{Trap} introduces only $2$.

The following theorem proves an upper bound on the
span of \proc{Strap} under the same conditions
as in \thmref{HyperspaceCutSimpleCase}. The proof
is a straight-forward extension of the observation
above, and hence has been omitted.

\begin{theorem}
The span of \proc{Strap} when visiting a trapezoid $\m{T}$ 
with ${\widehat{w}}_i = h, \forall{i} \in [0, d)$,
is $T_{\infty}(\m{T}) = \Th{h^{\lg{(2^d + 1)}}}$, where 
$h$ is the height of $\m{T}$, and
${\widehat{w}}$ is its normalized width in the $i$-th 
spatial dimension.
\label{thm:SpaceCutSimpleCase}
\end{theorem}

A corollary similar to \corref{HyperspaceCutSimpleCase}
follows.

\begin{corollary}
The span of \proc{Strap} when visiting a trapezoid $\m{T}$ 
with ${\widehat{w}}_i = w, \forall{i} \in [0, d)$,
and $h = 2^k w$ for some integer $k \geq 0$,
is $T_{\infty}(\m{T}) = \Th{ h^{1 + \lg{(2^d + 1)} } / w }$, where 
$h$ is the height of $\m{T}$, and
${\widehat{w}}$ is its normalized width in the $i$-th 
spatial dimension.
\label{cor:SpaceCutSimpleCase}
\end{corollary}

\punt{
The following theorem gives an upper bound on the span of 
\proc{Trap\_Seq}.
%
The proof is a straight-forward extension of the proof
for the one dimensional case (i.e., $d = 1$) of \proc{Trap\_Seq}
in \cite{FrigoSt09}, and hence has been omitted from this extended abstract.


\begin{theorem}
The critical path length (i.e., span) of \proc{Trap\_Seq} 
when visiting a trapezoid $\m{T}$ is $T_{\infty}(\m{T}) = 
\Oh{{\left( {\sigma} r \right)}^d h {\prod_{i = 0}^{d - 1}{w_{i}^{\alpha}}}}$, where 
$r > 1$, $\alpha = \frac{1}{\lg{(2(r - 1))}}$, $h$ is the height
of $\m{T}$ and $w_{i}$ is its width in the $i$-th ($0 \leq i < d$) 
spatial dimension. 
\label{thm:SeqSpaceCutNew}
\end{theorem}
\racnote{this theorem assumes that $w_i$ is the average of the two parallel sides}
}
% punt ends

The cache complexities of \proc{Trap} and \proc{Strap} 
are the same which follows from the observation that
both algorithms apply exactly the same time cuts
in exactly the same order, and immediately before 
each time cut both are in exactly the same state 
in terms of the spatial cuts applied.
%
Thus they arrive at exactly the
same configuration\footnote{number, shape and size} 
of subtrapezoids before each time cut.
For any fixed integer $r > 1$, a space cut in 
Frigo and Strumpen's parallel stencil algorithm 
produces $r$ black trapezoids and between $r - 1$
and $r + 1$ gray trapezoids. \proc{Strap} is
a special case of that algorithm with $r = 2$.
For larger values of $r$ Frigo and Strumpen's algorithm
achieves more parallelism but the cache efficiency
drops. Our algorithm (\proc{Trap}) can also be
modified to work with the same larger values of $r$
and achieve even more parallelism than that
algorithm while asymptotically matching its 
cache complexity.


In \figref{Parallelism} we employ the Cilkview scalability analyzer
\cite{YuxiongLe10} to compare the parallelism between \proc{Trap} and
\proc{Strap}.  In order to compare with the theoretical analyses, we
measured parallelism with an uncoarsened base case.
% \racnote{The sentence starting with ``So the stop condition ...'' is not clear to me. Needs to be fixed}
% So the stop condition for base case is that the height on time dimension equals one ($1$)
% and at the mean time the algorithm can not cut into any spatial dimension when preserving the \defn{well-formness}.
In \figref{Parallelism} \proc{Trap} does demonstrate an asymptotic improvement in
parallelism over Frigo and Strumpen's original parallel algorithm.

We used the Linux perf tool \cite{perf} in order to verify that
\proc{Trap} does not suffer any loss in cache efficiency compared to
the original space-cut algorithm. \figref{CacheComplexity} also plots
the cache miss ratio of straightforward parallel loop
algorithm. Clearly the parallel loop algorithm exhibits poorer cache
performance compared to both cache oblivious algorithms.
% The cache miss ratio of parallel loop algorithm may approach to $100\%$ with the increasing of
% data set size.

\definecolor{Red}{rgb}{0.5,0,0}
\definecolor{Blue}{rgb}{0,0,0.5}
\definecolor{Black}{rgb}{0,0,0}
\begin{figure}
\centering
\subfigure[]{\input{heat_2D_P_span.tex}}
\label{fig:heat2DPSpan}

\subfigure[]{\input{heat_2D_NP_span.tex}}
\label{fig:heat2DNPSpan}

\subfigure[]{\input{dfd_span.tex}}
\label{fig:dfdSpan}

\caption{Parallelism comparison between space cut and hyperspace cut.   This measurement is of code without base-case coursening.
 (a) 2D periodic heat equation.  Space-time size is $1000N^2$.
 (b) 2D nonperiodic heat equation. Space-time size is $1000N^2$.
 (c) 3D wave equation.   Space-time size is $1000N^3$.
}
\label{fig:Parallelism}
\end{figure}

\begin{figure}
\centering
\subfigure[]{\input{heat2DPCache}}
\label{fig:heat2DPCache}

\subfigure[]{\input{heat2DNPCache}}
\label{fig:heat2DNPCache}

\subfigure[]{\input{dfdCache}}
\label{fig:dfdCache}
\caption{Cache miss ratios of the two trapezoidal algorithms and the loop-based algorithm on three applications.  The cache miss ratio is the ratio of the cache misses to the number of memory references.  This measurement is of code without base-case coursening.
 (a) 2D periodic heat equation.  Space-time size is $1000N^2$.
 (b) 2D non-periodic heat equation.  Space-time is $1000N^2$.
 (c) 3D wave equation.  Space-time is $1000N^3$.
}
\label{fig:CacheComplexity}
\end{figure}

\punt{ According to Cilkview \cite{YuxiongLe10}, for 3D fluid-dynamic
  benchmarks of spatial grid $500 \times 500 \times 500$, and $500$
  time steps, the hyperspace-cut algorithm improves the parallelism by
  $37\%$ and shortens the span by~$29\%$
  (\figref{cmpSeqSim}.

\begin{figure*}[!t]
\center
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
App & Size & Time & \multicolumn{2}{|c|}{Space Cut} & \multicolumn{2}{|c|}{Hyperspace Cut} & Speedup & Speedup \\
\cline{4-5} \cline{6-7} 
    &      & Steps & Span & Parallelism & Span & Parallelism & Span & Parallelism \\
\hline
3dfd & $500^3$ & $500$ & $58.8e9$ & $29.04$ & $42.3e9$ & $40.30$ & $39\%$ & $37\%$ \\
\hline
3dfd & $800^3$ & $600$ & $218.7e9$ & $38.93$ & $178.6e9$ & $47.67$ & $22\%$ & $23\%$ \\
\hline
\end{tabular}
\caption{Comparison of span and parallelism between space cut and hyperspace cut}
\label{fig:cmpSeqSim}
\end{figure*}
}

\punt{
%
The proof is a straight-forward extension of the proof
for the 1D case (i.e., $d = 1$) in \cite{FrigoSt09}.
As in \cite{FrigoSt09} we will assume that a call to 
the kernel function and a spawn cost at most one unit 
of the critical path.

We will show that 
%
%\begin{equation}
$T_{\infty}(\m{T}) \leq 
{\left( 2 {\sigma} r \right)}^d \left( 2h {\prod_{i = 0}^{d - 1}{w_{i}^{\alpha}}} - 1 \right)$.
%\label{eq:SeqSpaceCutBound}
%\end{equation}
%
The proof is by induction on the volume of the
trapezoid.

% \noindent
% \phead{Base Case} 
In the base case $h = 1$ and $1 \leq w_i < 2\sigma r$
for all $i \in [0, d)$. Since the spatial grid is a hyperrectangle,
we have $T_{\infty}(h, w_0, w_1, \ldots, w_{d - 1}) 
= \prod_{ i = 0 }^{d - 1}{w_i} \leq {\left( 2 \sigma r \right)}^d
\leq {\left( 2 {\sigma} r \right)}^d \left( 2h {\prod_{i = 0}^{d - 1}{w_{i}^{\alpha}}} \right)$,
and so the bound holds.

If we are not in the base case, the trapezoid is recursively cut 
the into strictly smaller subtrapezoids 
for which the bound holds. Either a time cut or a space
cut is applied.

For a time cut, let $u_{i}$ (resp. $v_{i}$) be the width of the lower 
(resp. upper) subtrapezoid for spatial dimension $i$. Then we have,
%
\begin{eqnarray*}
T_{\infty}(h, w_0, w_1, \ldots, w_{d - 1})
& \leq & T_{\infty}{\left(\frac{h}{2}, u_0, u_1, \ldots, u_{d - 1}\right)}
+ T_{\infty}{\left(\frac{h}{2}, v_0, v_1, \ldots, v_{d - 1}\right)} + 1~\\
& \leq & {\left( 2 {\sigma} r \right)}^d \left( h {\prod_{i = 0}^{d - 1}{u_{i}^{\alpha}}} - 1 \right)
 + {\left( 2 {\sigma} r \right)}^d \left( h {\prod_{i = 0}^{d - 1}{v_{i}^{\alpha}}} - 1 \right) + 1~\\  
\end{eqnarray*}

Since $\alpha \leq 1$, by Jensen's inequality, $u_{i}^{\alpha} + v_{i}^{\alpha}
\leq 2{\left( \frac{ u_{i} + v_{i} }{2} \right)}^{\alpha} = 2w_{i}^{\alpha}$.
Hence,
%
\begin{eqnarray*}
T_{\infty}(h, w_0, w_1, \ldots, w_{d - 1})
& \leq & {\left( 2 {\sigma} r \right)}^d \left( 2h {\prod_{i = 0}^{d - 1}{w_{i}^{\alpha}}} - 2 \right) + 1  
 \leq  {\left( 2 {\sigma} r \right)}^d \left( 2h {\prod_{i = 0}^{d - 1}{w_{i}^{\alpha}}} - 1 \right)~\\
\end{eqnarray*}

For space cut, suppose w.l.o.g. that dimension 0 is cut. Let $w_{0b}$
(resp. $w_{0g}$) be the width of black (resp. gray) subtrapezoids
in spatial dimension 0. Then $w_{0g} = \sigma h$ and
$w_{0b} \leq \frac{w_{0} - (r - 1) w_{0g}}{r} \leq \frac{w_{0}}{r - 1} - w_{0g}$.
Hence
%
\begin{eqnarray*}
T_{\infty}(h, w_0, w_1, \ldots, w_{d - 1})
& \leq & T_{\infty}{\left(h, w_{0b}, w_1, \ldots, w_{d - 1}\right)}
+ T_{\infty}{\left(h, w_{0g}, w_1, \ldots, w_{d - 1}\right)} + 2r~\\
& \leq & {\left( 2 {\sigma} r \right)}^d \left( 2h {\left( w_{0b}^{\alpha} + w_{0g}^{\alpha} \right)} 
  {\prod_{i = 1}^{d - 1}{w_{i}^{\alpha}}} - 2 \right) + 2r~\\  
& \leq & {\left( 2 {\sigma} r \right)}^d \left( 2h {\left( \frac{2 w_0^{\alpha}}{(2r - 2)^{\alpha}} \right)} 
  {\prod_{i = 1}^{d - 1}{w_{i}^{\alpha}}} - 2 \right) + 2r~\\
& = & {\left( 2 {\sigma} r \right)}^d \left( 2h 
  {\prod_{i = 0}^{d - 1}{w_{i}^{\alpha}}} - 2 \right) + 2r~~
 \left[\textrm{since}~ \alpha = \frac{1}{\lg{(2(r - 1))}} \Rightarrow \frac{2 w_0^{\alpha}}{(2r - 2)^{\alpha}} 
 = w_0^{\alpha}\right]~\\
& = & {\left( 2 {\sigma} r \right)}^d \left( 2h 
  {\prod_{i = 0}^{d - 1}{w_{i}^{\alpha}}} - 1 \right)~\\
\end{eqnarray*}

Thus the bound continues to hold.
%
\end{proof}
}






\punt{
\subsecput{SeqSpaceCut}{A {Sequential-Space-Cut} extension of cache-oblivious arbitrary $d$-dimensional parallel stencil algorithm}

In \cite{FrigoLePr99}, Frigo and Leiserson first coined the term
"Cache Oblivious Algorithm" and introduced several cache oblivious
algorithms for classic problems, such as matrix multiplication, matrix
transposition, FFT, funnelsort, and distribution
sort. In \cite{FrigoSt05}, they invented a sequential cache oblivious
algorithm for stencil computation. In \cite{FrigoSt09}, Frigo and Strumpen
parallelized $1$-dimensional algorithm. This parallelization can be
further generalized to an arbitrary $d$-dimensional 
stencil as illustrated in \figref{naiveDDcode}


\begin{mydef}
\textbf{ Well-Defined Trapezoid: } we call a $d$-dimensional grid
$T(t_0, t_1, (\forall i, 0 \leq i < d, x_0[i], x_1[i], dx_0[i], dx_1[i]))$ a 
well-defined trapezoid $\iff$ the following three ($3$) conditions hold:
\begin{enumerate}
	\item $t_1 \geq t_0$
	\item $\forall i, 0 \leq i < d, x_1[i] \geq x_0[i]$
	\item $\forall i, 0 \leq i < d, x_1[i] + \Delta t \times dx_1[i] \geq x_0[i] + \Delta t \times dx_0[i]$
\end{enumerate}
\label{def:wellDefinedTrapezoid}
\end{mydef} 

In \defref{wellDefinedTrapezoid}, $d$ is the number of spatial
dimensions, $t_1 - t_0$ is the height, and $(\forall i, 0 \leq i < d, x_0[i],
x_1[i], dx_0[i], dx_1[i]))$ represents the spatial plane. 
$x_0[i]$ and $x_1[i]$ defines the begining and end
point of the trapezoid on spatial dimension $i$, $dx_0[i]$ and
$dx_1[i]$ defines the slopes at point $x_0[i]$ and
$x_1[i]$, and is computed out of formula
$dx_0[i] = \Delta x_0[i] / \Delta t$, $dx_1[i] = \Delta x_1[i] /
\Delta t$, respectively. We say a trapezoid has color \emph{black} on spatial dimension
$i \iff dx_0[i] \geq 0 \wedge dx_1[i] \leq 0$ is true, otherwise,
we call the color of this trapezoid on spatial dimension $i$ is \emph{gray}.
And we only consider well-defined trapezoid as in \defref{wellDefinedTrapezoid}

\begin{mydef}
\textbf{ Parallel Space Cut:} \cite{FrigoSt09} For any one of spatial dimension, we cut
it into $r$ black trapezoids and some number of gray trapezoids, where $r \geq 1$.
\label{def:parallelSpaceCut}
\end{mydef}

In \cite{FrigoSt09}, Frigo and Strumpen invented parallel space-cut technique to parallelize a $1$-dimensional 
stencil. This same technique can be recursively applied to all spatial dimensions of an arbitrary 
$d$-dimensional trapezoid to get a straightforward extension of parallel arbitrary $d$-dimensional 
cache-oblivious
stencil algorithm as in \figref{naiveDDcode}. And we call it \textbf{Space Cut} algorithm due to the fact that this algorithm recursively cut into each spatial dimension one after another.
%
%By employing the parallel 
%$1$-dimensional space-cut algorithm to that spatial dimension, we cut each
%existing trapezoid into two subtrapezoids, one with color black on dimension $i$,
%the other has color gray. All trapezoids with color
%black on dimension $i$ will be put into one parallel step, 
%and all trapezoids with color gray on dimension $i$ will be put 
%into a distinct parallel step, and put a \func{sync} operation 
%in between to preserve the data dependency. We treat all spatial dimensions 
%symmetrically and independently.

This straightforward extension of $1$-dimensional parallel space-cut algorithm
to sequential space-cut algorithm seems to solve the problem
quite well. But, we should always ask ourselves the same old question:
"Can we do better?"


\subsecput{SimSpaceCut}{A hyperspace-cut extension of
  cache-oblivious arbitrary $d$-dimensional parallel stencil
  algorithm}

\begin{mydef}
\textbf{Parallel Step:} We call certain number of subtrapezoids in
one parallel step, if there are no \func{sync} operation separating
these subtrapezoids.
\label{def:parallelStep}
\end{mydef}

Let's take a $1$-dimensional trapezoid as an example. Assuming that, 
in the space-cut algorithm, by each space cut, we cut
one big trapezoids into $r$ black subtrapezoids, and $r+1$ gray
subtrapezoids. And all these $2r+1$ subtrapezoids will be executed
in two ($2$) parallel steps. The first parallel step executes all black 
subtrapezoids, and the second parallel step executes all gray ones.

From \defref{parallelStep} we can easily see that if there are
infinite number of processors, we can execute all subtrapezoids in 
one parallel step simultaneously on all processors, and the execution time will be
constrained by the longest critical path of these subtrapezoids. More
over, if we assume all these subtrapezoids are of unit length, 
all subtrapezoids in one parallel step can be finished in just one unit
time.

\punt{
\begin{figure}[ht]
\centering
\subfigure[$1$D Time Cut]{\includegraphics[clip,scale=0.6]{figures/1D_Time_Cut.eps}
\label{fig:1DTimeCut}}
\subfigure[$1$D Parallel Space Cut]{\includegraphics[clip,scale=0.6]{figures/1D_Parallel_Cut.eps}
\label{fig:1DParallelCut}}
\caption{$1$D Divide-and-conquer, both in time dimension and spatial dimension}
\label{fig:1DCut}
\end{figure}
}

\begin{figure}[ht]
\centering
\subfigure[$2$D Parallel Space Cut, first cut into dimension $X$]{\includegraphics[clip,scale=0.6]{figures/2D_Cut_X.eps}
\label{fig:2DCutX}}
\subfigure[$2$D Parallel Space Cut, first cut into dimension $X$, second cut into dimension $Y$]{\includegraphics[clip,scale=0.6]{figures/2D_Cut_XY.eps}
\label{fig:2DCutXY}}
\caption{$2$D Divide-and-conquer on spatial dimensions, first cut into dimension $X$, then dimension$Y$}
\label{fig:2DSpatialCut}
\end{figure}

After we understand how $1$D space cut works, we can look
into the $2$-dimensional cases. In \figref{2DCutX}, we have a $2+1$-dimensinoal
grid. If we first cut into dimension $X$, we will have $5$ pieces,
that is, grid $1, 2, 3, 4, 5$. And we will put a \func{sync} between
grid $2, 4$ and grid $1, 3, 5$. So we will have following two parallel
steps:

\begin{codebox}
Parallel Step 1: \func{spawn} $grid_2, grid_4$ \\
\func{sync} \\
Parallel Step 2: \func{spawn} $grid_1, grid_3, grid_5$ 
\end{codebox}

Then, we cut into dimension $Y$ by applying the same parallel $1+1$-dimensional
space-cutting strategy to all $5$ pieces and have the data
layout as illustrated in \figref{2DCutXY}. Consequently, we will have
following four parallel steps:

\begin{codebox}
Parallel Step 1: \func{spawn} $grid_{22}, grid_{24}, grid_{42}, grid_{44}$ \\
\func{sync} \\
Parallel Step 2: \func{spawn} $grid_{21}, grid_{23}, grid_{25}, grid_{41}, grid_{43}, grid_{45}$ \\
\func{sync} \\
Parallel Step 3: \func{spawn} $grid_{12}, grid_{14}, grid_{32}, grid_{34}, grid_{52}, grid_{54}$ \\
\func{sync} \\
Parallel Step 4: \func{spawn} $grid_{11}, grid_{13}, grid_{15}, grid_{31}, grid_{33}, grid_{35},$ \\
$grid_{51}, grid_{53}, grid_{55}$ \\
\end{codebox}

This parallel execution pattern of $2$-dimensional stencil seems quite reasonable.
But suppose we cut into dimension $Y$ before cutting into $X$ by employing the same parallel 
$1+1$-dimensional algorithm, following the numbering in \figref{2DCutXY}, we will have parallel steps:

\begin{codebox}
Parallel Step 1: \func{spawn} $grid_{22}, grid_{24}, grid_{42}, grid_{44}$ \\
\func{sync} \\
Parallel Step 2: \func{spawn} $grid_{12}, grid_{14}, grid_{32}, grid_{34}, grid_{52}, grid_{54}$ \\
\func{sync} \\
Parallel Step 3: \func{spawn} $grid_{21}, grid_{23}, grid_{25}, grid_{41}, grid_{43}, grid_{45}$ \\
\func{sync} \\
Parallel Step 4: \func{spawn} $grid_{11}, grid_{13}, grid_{15}, grid_{31}, grid_{33}, grid_{35},$ \\
$grid_{51}, grid_{53}, grid_{55}$ \\
\end{codebox}

We can see that the only change between two different cutting order on
spatial dimensions lies in the parallel step $2$ and $3$. Further
investigation reveal that it's un-necessary to put a \func{sync}
between these two parallel steps, because there are no data dependence
between the grids at parallel step $2$ and $3$ at all. These grids are
separated only because we employ the same parallel $1$-dimensional
algorithm on all spatial dimensions one after another. So, if we can
find some way to remove this un-necessary \func{sync}, we will have
more parallelism and we will shorten the critial path (span). This
simple idea leads to the hyperspace-cut algorithm 
for arbitrary $d$-dimensional stencil as the $2$-dimensional example
illustrated in \figref{trap-code}.

The procedure \func{TRAP} decomposes a trapezoid $T$ recursively
into subtrapezoids, according to following rules:

\begin{itemize}

	\item Hyperspace Cut: We don't conduct a parallel
          space cut until all the spatial dimensions can perform such
          a cut. That is, $\forall i, 0 \leq i < d, s.t. x_1[i] - x_0[i]
          \geq r \times (2 \sigma (t_1 - t_0))$. ($r$ is the number of
          black subtrapezoid in each space cut). This cutting
          threshold guarantees that after the hyperspace cut,
          the projection of any subtrapezoid on any spatial dimension
          will still maintain well-defined \defref{wellDefinedTrapezoid}.  
          If all spatial dimensions can perform a
          space cut, we use a parallel loop to spawn all
          subtrapezoids of the same dependency level as illustrated
          in \figref{trap-code}.
	
	\item Time Cut: The cut into time dimension will be identical
          to that in space cut, that is, if $t_1 - t_0 > 1$
          and hyperspace cut is not applicable, procedure
          \func{TRAP} will cut the trapezoid along the
          horizontal line through the center, as illustrated in
          \figref{1DTimeCut}. The recursion first traverses the
          bottom subtrapezoid $T_{bottom} = T(t_0, t_0 + \delta t,
          (\forall i, 0 \leq i < d, s.t. x_0[i], x_1[i], dx_0[i],
          dx_1[i]))$, and then upper subtrapezoid $T_{up} = T(t_0 +
          \delta t, t_1, (\forall i, 0 \leq i < d, s.t. x_0[i] + dx_0[i]
          \times \delta t, x_1[i] + dx_1[i] \times \delta t))$, where
          $\delta t = \Delta t / 2 = (t_1 - t_0)/2$
	
	\item Base case: If $t_1 - t_0 = 1$, we visit all the points
          in the trapezoid by applying the application specific
          computing \func{kernel} to it.
\end{itemize}

%In \figref{trap-code}, we also illustrated one implementation of simultaneous space cut, which has the effect of cutting into all spatial dimensions at the same time. There can be more different implementations. \figref{simDDSpaceCode} is just one possible implementation. The basic idea is to use a toggle'd circular queue to simulate the behavior of recursive space cut. In each space cut, instead of putting a \func{sync} between black and gray subtrapezoid, we put them in different circular queue to represent the potential data dependence between them. After completed the space cuts on all spatial dimensions, all subtrapezoids in the circular queue of the same dependency level will be spawned in the same parallel step. 

%More formally:
%
%\begin{itemize}
%	\item We define a toggle'd circular queue to hold all subtrapezoids which have not completed the space cut on all spatial dimensions. 
%	\begin{description}
%		\item For the toggle'd circular queue, we use the real dependency level to index the queue. The real dependency level is generated respectively for black and gray subtrapezoids in any space cut.
%		\item Each element in the circular queue consists of a $d+1$ spacetime subtrapezoid $T(t_0, t_0 + \delta t, (\forall i, 0 \leq i < d, x_0[i], x_1[i], dx_0[i], dx_1[i]))$, and $level$, which records how many space cuts has been conducted so far for the subtrapezoid.
%	\end{description}
%
%	\item We only spawn the subtrapezoids in the circular queue after they have completed space cuts on all spatial dimensions. 
%	
%	\item We cut all trapezoids in the circular queue from dimension $0$ to $d-1$ in a strict order. So for any subtrapezoid in the circular queue, if it hasn't completed all its space cut, that is, $level < d$, we will conduct a space cut on its next spatial dimension $level+1$ by following rules:
%	\begin{itemize}
%		\item For each space cut, we put all black subtrapezoids into the \id{circular\_queue} of the same dependency level (\id{curr\_dep\_pointer}) as its father trapezoid.
%	
%		\item For each space cut, we put all gray subtrapezoids into the \id{circular\_queue} of the toggled dependency level (\id{next\_dep\_pointer}) of its father trapezoid.
%	\end{itemize}
%		
%	\item We won't start processing any subtrapezoid in a circular queue of \id{next\_dep\_pointer} before we drain the subtrapezoid in the circular queue of \id{curr\_dep\_pointer}. So we need only two ($2$) toggled circular queue.
%\end{itemize}

The main difference between \figref{naiveDDcode} and
\figref{trap-code} is that in \figref{naiveDDcode}, we cut into all spatial
dimension one after another, and consequently, put one ($1$)
un-necessary \func{sync} for each spatial dimension cut. While in
\figref{trap-code}, we have the effect of cutting into all spatial
dimensions at the same time, and put a \func{sync} only when there's a
real data dependence between two parallel steps.

%\begin{figure}[ht]
%\begin{codebox}
%\Procname {\proc{sim\_walk\_d}$(t_0, t_1, grid)$}
%\li $\Delta t \gets t_1 - t_0$
%\li \id{can\_cut} $= \bigwedge_{i=0}^{d} (grid.x_1[i] - grid.x_0[i] \geq 2 * (2 * \sigma[i] * \Delta t)$
%\li \If (\id{can\_cut}) \Comment simultaneous space cut \label{li:canCut}
%\li \> \For $i \gets 0$ \To $d+1$ \label{li:allDep}
%\li \> \> \func{Parallel} \For \label{li:parallelSpawnBegin}
%\li \> \> \> \func{sim\_walk\_d}$(t_0, t_1, grid^i)$ \label{li:parallelSpawnEnd}
%%\li \> \func{sim\_space\_cut}$(t_0, t_1, grid)$
%\li \ElseIf $(\Delta t > 1)$ \Comment time cut
%\li \> \> $\delta t \gets \Delta t / 2 $
%\li \> \> \func{sim\_walk\_d}($t_0$, $t_0 + \delta t$, bottom trapezoid)
%\li \> \> \func{sim\_walk\_d}($t_0 + \delta t$, $t_1$, upper trapezoid)
%\li \Else \Comment base case
%\li \> \> \func{kernel}$(t_0, t_1, grid)$
%\end{codebox}
%\caption{A simultaneous space cut extension of cache-oblivious arbitrary $d$-dimensional parallel stencil algorithm from \cite{FrigoSt09}. \liref{canCut} judge whether all spatial dimension can conduct a space cut. If so, \lirefs{allDep}{parallelSpawnEnd} will do the real job of simultaneous space cut. Because for $d$-dimensional spatial grid, it will have at most $d+1$ real data dependence among all subtrapezoids, \liref{allDep} just go through all these subtrapezoids which have different dependency level. \Lirefs{parallelSpawnBegin}{parallelSpawnEnd} use the parallel for to spawn all subtrapezoids having the same dependency level $i$ ($grid^i$)}
%\label{fig:trap-code}
%\end{figure}

%To compute the dependency level for each subtrapezoid, we have
%following simple algorithm: For each space cut, we divide it into
%black and gray subtrapezoid. For black subtrapezoids, they can be
%run without any wait on dependence, while for the gray subtrapezoids,
%they have to wait for the black trapezoids finish. So it's an
%additional dependence. So, for one space cut, if we cut a spatial
%dimension into $r$ black subtrapezoids and $r+1$ gray
%subtrapezoids. Then we can use a $2r+1$ element vector to represent
%the space cut. In this $2r+1$ long vector, we use $0$ to fill the
%position of a black subtrapezoid, $1$ to fill the position of a gray
%subtrapezoid. For example, if a space cut generates $1$ black
%subtrapezoid, and $2$ gray subtrapezoid, then the vector will be
%$(x_0, x_1, x_2) = (1, 0, 1)$, if a space cut generates $2$ black
%subtrapezoid, and $3$ gray subtrapezoid, then the vector will be
%$(x_0, x_1, x_2, x_3, x_4) = (1, 0, 1, 0, 1)$. For an arbitrary
%$d$-dimensional space, we will have $d$ vectors, $(x_0^0, x_1^0,
%\ldots, x_{2r}^0), \ldots, (x_0^{d-1}, x_1^{d-1}, \ldots,
%x_{2r}^{d-1})$, where subscript is the index within vector,
%superscript is the id of spatial dimension. So, for any subtrapezoid
%has the index pair on all spatial dimensions, $\ang{x_{i_0}^0,
%  x_{i_1}^1, \ldots, x_{i_{d}}^d}$, the dependency level is just a
%simple sum of all indices, that is $\sum_{j = 0}^{d} x_{i_j}^j$. For a
%simple instance, if it's a $2$D spatial grid, and each space cut
%generates $2$ black subtrapezoids, and $2$ gray subtrapezoids, we
%can use the matrix in \figref{Dep2D5} to get the dependency level of
%each subtrapezoid after simultaneous space cut.


\begin{figure}[ht]
\centerline{\mbox{\includegraphics[clip,scale=0.6]{figures/dependence_pattern_2D_5.eps}}}
\caption{dependency level pattern for hyperspace cut in a $2$D spatial grid, assuming each space cut will generate $2$ black subtrapezoids and $3$ gray subtrapezoids on each spatial dimension.}
\label{fig:Dep2D5}
\end{figure}

%\begin{figure}[ht]
%\begin{codebox}
%\li typedef struct \{
%\li \> \Comment $level$ is how many dimensions we have cut so far
%\li \> int $level$;  
%\li \> int $t_0$, $t_1$;
%\li \> $grid\_info$<$d$> $grid$;
%\li \} queue\_info;
%\li \Comment It's a toggle'd circular queue
%\li queue\_info circular\_queue\_[2][QUEUE\_SIZE]
%\li \func{sim\_space\_cut}$(t_0, t_1, grid)$
%\li \Comment \func{Enqueue}$(dep, level, t_0, t_1, grid)$
%\li \Comment \func{Top\_queue}$(dep, queue_elem)$
%\li \Comment \func{Dequeue}$(dep)$
%\li \Comment Enqueue the initial $d+1$ spacetime grid into 
%\li \Comment circular queue[0]
%\li \func{Enqueue}$(queue[0], (0, t_0, t_1, grid))$ \label{li:enqInitialElement}
%\li \Comment We can prove that for $d+1$ spacetime grid, 
%\li \Comment it will introduce at most $d+1$ real data dependences,
%\li \Comment that is, at most $d+1$ syncs are needed
%\li \For $curr\_dep \gets 0$ \To $d$ \label{li:beginFor}
%\li \> \Comment \id{curr\_dep} \& 0x1 to get the index to the toggled queue
%\li \> $curr\_dep\_pointer \gets (curr\_dep \& 0x1)$
%\li \> \While $queue\_len\_[curr\_dep\_pointer] > 0$ \label{li:beginWhile}
%\li \> \> \Comment l\_father will point to the top element of the 
%\li \> \> \Comment queue[curr\_dep\_pointer]
%\li \> \> \func{Top\_queue}$(curr\_dep\_pointer, l\_father)$
%\li \> \> \If $l\_father.level = d$ \label{li:doneCut}
%\li \> \> \> \Comment the spatial grid pointed by l\_father 
%\li \> \> \> \Comment has finished all spatial cut of this round
%\li \> \> \> \For $i \gets queue\_head\_[curr\_dep\_pointer]$ \label{li:beginSpawn}
%\li \> \> \> \> \> \To \mbox{$queue\_tail\_[curr\_dep\_pointer]$}
%\li \> \> \> \> \Comment Making \id{l\_son} pointing to the top element in  
%\li \> \> \> \> \Comment \id{circular\_queue\_[\id{curr\_dep\_pointer}]}
%\li \> \> \> \> \func{Top\_queue}$(curr\_dep\_pointer, l\_son)$
%\li \> \> \> \> \func{spawn} \func{sim\_walk\_d} $(l\_son.t_0, l\_son.t_1, l\_son.grid)$
%\li \> \> \> \> \func{Dequeue}$(curr\_dep\_pointer)$ \label{li:endSpawn}
%\li \> \> \Else \Comment perform a space cut on dimension 'level'
%\li \> \> \> \func{Dequeue}$(curr\_dep\_pointer)$
%\li \> \> \> \For $i \gets 0$ \To $r$ \label{li:beginSpawnBlack}
%\li \> \> \> \> \func{Enqueue}$(queue[curr\_dep\_pointer], (level+1$, 
%\li \> \> \> \> \> \> \> $l\_father.t_0, l\_father.t_1$, 
%\li \> \> \> \> \> \> \> $l\_father.sub\_black\_trapezoid))$ \label{li:endSpawnBlack}
%\li \> \> \> \Comment following is the spatial grid to be put in next dep level
%\li \> \> \> $next\_dep\_pointer \gets (curr\_dep + 1) \& 0x1$ \label{li:incDep}
%\li \> \> \> \For $i \gets 0$ \To $r+1$ \label{li:beginSpawnGray}
%\li \> \> \> \func{Enqueue}$(queue[next\_dep\_pointer], (level+1$, 
%\li \> \> \> \> \> $l\_father.t_0, l\_father.t_1$, 
%\li \> \> \> \> \> $l\_father.sub\_gray\_trapezoid))$ \label{li:endSpawnGray}
%\li \> \Comment end of \While $queue\_len\_[curr\_dep\_pointer] > 0$ \label{li:endWhile}
%\li \Comment end of \For $curr\_dep \gets 0$ \To $d$ \label{li:endFor}
%\end{codebox}
%\caption{One implementation of how to cut into all spatial dimensions simultaneously}
%\label{fig:simDDSpaceCode}
%\end{figure}
%
%In \figref{simDDSpaceCode}, in \liref{enqInitialElement}, we push the
%initial un-cut trapezoid into circular queue, starting from index
%$0$. From \lirefs{beginFor}{endFor}, we conduct all $d$ space cut on
%all trapezoids in circular queues. From \lirefs{beginWhile}{endWhile},
%we check each trapezoid in the head of circular queue of index
%\id{curr\_dep\_pointer}, if it has completed all $d$ space cuts, we
%step into a spawning process, otherwise, we perform a space cut on its
%$level+1$ spatial dimension. In \liref{doneCut}, we check if the head
%of circular queue of index \id{curr\_dep\_pointer} has done all the
%space cut, we spawn all the trapezoids in this circular queue from
%queue head to queue tail. Because we put the trapezoid in a queue, so
%if the head element of the circular queue has done all its space cut,
%all the subsequent trapezoids must have done their space cut as
%well. So, we use a parallel for loop to spawn all the trapezoid from
%head to tail. If the trapezoid has not done all its space cut, from
%\lirefs{beginSpawnBlack}{endSpawnGray}, we cut it on the spatial
%dimension $level+1$ by employing the $1$-dimensional parallel cutting
%algorithm. But instead of directly spawning, we put all black
%subtrapezoid into the circular queue of the same dependency level of
%its father trapezoid, and put all gray subtrapezoid into the circular
%queue of next dependency level to identify the data dependence
%between these two different types of subtrapezoids.
}
% punt ends


\punt{

\subsecput{ParallelismAnalysis}{Parallelism analysis}

If we assume that initial trapezoid $T(t_0, t_1, (\forall i, 0 \leq i
< d, x_0[i], x_1[i], dx_0[i], dx_1[i]))$ has $d$ spatial dimensions,
and for each space cut, we cut it into $r$ black subtrapezoids, and
$r+1$ gray subtrapezoids, on that spatial dimension. We assume that total number of 
points in $d+1$-dimensional spacetime grid are $N$. We use $A$ to represent a
space cut, $A_i$ to represent a space cut on dimension $i$, $B$ to
represents a time cut, then we will have following lemmas and theorems :

\begin{lemma}
For Space Cut algorithm, if we don't count in time cut, 
after cutting into all $d$ spatial dimensions one after another, we 
will have $2^d$ number of parallel steps.
\label{lem:seqParallelSteps}
\end{lemma}
The proof appears in \appref{proofs}.

\begin{lemma}
For Hyperspace-cut algorithm, if we don't count in time cut, after cutting
all $d$ spatial dimensions, we will have $d+1$ number of parallel steps.
\label{lem:simParallelSteps}
\end{lemma}
The proof appears in \appref{proofs}.

%\begin{figure}[ht]
%\centerline{\mbox{\includegraphics[clip,scale=0.6]{figures/1D_Multi_Time_Cut.eps}}}
%\caption{$1$D Multiple Time Cut}
%\label{fig:1DMultiTimeCut}
%\end{figure}


\begin{theorem}
For Space-Cut algorithm, the span (critical-path length) of the
algorithm will be $\Theta (N^{\log_{(t \cdot (2r+1)^d)} (t \cdot 2^d)})$,
where $t$ is the number of time cut that guarantees if conducting $t$
time cuts for each turn cutting into time dimension, we can
always cut into some spatial dimension right after. Such $t$ always exists 
because in the worst case, for a trapezoid of height $h$, we can always cut it into
$h$ subtrapezoids of height $1$, and for each subtrapezoid, either 
it is qualified to be a base case, or it can have a space cut right after. 
\label{thm:SeqSpaceCut}
\end{theorem}
The proof appears in \appref{proofs}.
}
% punt ends



\punt{
\begin{theorem}
For Hyperspace-cut algorithm, the critical path (span) of the
algorithm will be $\Theta (N^{\log_{(t \cdot (2r+1)^d)} (t \cdot (d+1))})$,
where $t$ is the number of time cut that guarantees if conducting $t$
time cuts for each turn cutting into time dimension, we can
always cut into some spatial dimension right after. Such $t$ always exists 
because in the worst case, for a trapezoid of height $h$, we can always cut it into
$h$ subtrapezoids of height $1$, and for each subtrapezoid, either 
it is qualified to be a base case, or it can have a space cut right after. 
\label{thm:SimSpaceCut}
\end{theorem}
The proof appears in \appref{proofs}.
}
% punt ends






\punt{
\thmreftwo{SeqSpaceCut}{SimSpaceCut} give out the critical path (span)
of both algorithms. If we assume $r=1$, that is, each space cut, we
only cut into $1$ black subtrapezoid, and $2$ gray subtrapezoids. And we 
further assume that after each space cut, we just need to cut each trapezoid 
into $2r+1$ horizontally layered up subtrapezoid, then all those
subtrapezoids are either qualified for a base case, or can conduct
a space cut immediately. For hyperspace-cut algorithm, we assume the 
same parameter values. Then we can give out an apple-to-apple comparison on the critical path (span)
of both algorithms. as illustrated in \figref{cmpSeqSim}:

\begin{figure}
\center
\begin{tabular}{|l|c|c|}
\hline
d & exponent & exponent \\
  & of space cut & of hyperspace cut \\
\hline 
1 & $0.815$ & $0.815$ \\
2 & $0.754$ & $0.667$ \\
3 & $0.723$ & $0.565$ \\
4 & $0.705$ & $0.493$ \\
\hline
\end{tabular}
\caption{Comparison of the critical path (span) of space-cut algorithm and hyperspace-cut algorithm}
\label{fig:cmpSeqSim}
\end{figure}

From \figref{cmpSeqSim}, we can easily see that hyperspace-cut
algorithm improves the critical path(span) over space-cut algorithm
exponentially.  }
% punt ends

% LocalWords:  uncoarsened Strumpen's Frigo Cilkview subtrapezoids subtrapezoid
% LocalWords:  tuple interdependencies tuples parallelized Pochoir's Strumpen
% LocalWords:  antichain subgrids hyperrectangle
