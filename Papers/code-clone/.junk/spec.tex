% -*- Mode: LaTeX -*-
\secput{spec}{The Pochoir Specification Language}

%\subsection*{Specification of different boundary conditions}
%\label{sec:boundarySpec}

This section describes the formal syntax and semantics of the Pochoir
language, which was designed with a view to offer as much
expressiveness as possible without violating the Pochoir Guarantee.
The Pochoir language is specified to allow third-party developers to
interface their own libraries and compilers.

The static information about a Pochoir stencil computation, such as
the computing kernel, the boundary conditions, and the stencil shape,
is stored in a \defn{Pochoir object}, which is declared as follows:
\begin{closeitemize} 
\lstset{language=Pochoir_bf}
\item \code{Pochoir_}\id{dim}\code{D} \id{name};
\end{closeitemize}
This statement declares \id{name} as a Pochoir object with $\id{dim}$
spatial dimensions, where $\id{dim}$ is a small positive integer.

We now itemize the other Pochoir constructs and explain the role of
each.

\begin{closeitemize}
\lstset{language=Pochoir_bf}
\item \code{Pochoir_Shape_}\id{dim}\code{D} \id{name} \code+[] = {+\id{cells}\code+}+
\end{closeitemize}
This statement declares \id{name} as a \defn{Pochoir shape} that can
hold shape information for $\id{dim}$ spatial dimensions.  The Pochoir
shape is equivalent to an array of arrays, each of which contains
$\id{dim} + 1$ integer numbers.  These numbers represent the offset of
each memory footprint in the stencil kernel relative to the space-time
grid point $\ang{t, x, y, \cdots}$.  For example, suppose that the
computing kernel is the following $2$D Jacobi-style stencil:
\begin{eqnarray*}
  u_{t}(x,y) & = & u_{t-1}(x,y) \nonumber\\
   & & + \alpha (u_{t-1}(x-1,y) + u_{t-1}(x+1,y) - 2 u_{t-1}(x,y))\nonumber \\
   & & + \alpha (u_{t-1}(x,y-1) + u_{t-1}(x,y+1) - 2u_{t-1}(x,y))\ .
\end{eqnarray*}
The shape of this stencil is $\{\set{0, 0, 0}$,
  $\set{-1, 1, 0}$, $\set{-1, 0, 0}$, $\set{-1,
    -1, 0}$, $\set{-1, 0, 1}$, $\set{-1, 0,
    -1}\}$.
  
\begin{closeitemize}
\lstset{language=Pochoir_bf}
\item \code{Pochoir_Array_}\id{dim}\code{D(}\id{type}, \id{depth}) \id{name}\code{(}$\id{size}_{\id{dim}-1}, \ldots, \linebreak[0]\id{size}_1, \id{size}_0$\code{)}
\end{closeitemize}
% \begin{closeitemize}
%\lstset{language=Pochoir_bf}
%\item \code{Pochoir_Array<}\id{type}, \id{dim}, \id{depth}\code{>} \\
%  \id{name}\code{(}$\id{size}_{\id{dim}-1}, \ldots, \id{size}_1, \id{size}_0$\code{)}
%\end{closeitemize}
This statement declares \id{name} as a \defn{Pochoir array} of type
$\id{type}$ with $\id{dim}$ spatial dimensions.  The size of the $i$th
spatial dimension, where $0 \leq i < dim$, is given by $\id{size}_i$.
The user may not obtain an alias to the Pochoir array or its elements.

\begin{closeitemize}
\lstset{language=Pochoir_bf}
\item \code{Pochoir_Boundary_}\id{dim}\code{D}$(\id{name}, \id{array}, \id{idx}_t, \linebreak[0]\id{idx}_{\id{dim} - 1},\linebreak[0] \ldots, \linebreak[0]\id{idx}_1, \id{idx}_0)$ \\
     \hspace*{1em} $\ang{\id{definition}}$\\
     \code{Pochoir_Boundary_End}
\end{closeitemize}
This construct defines a \defn{boundary function} named \id{name} that
will be called to supply a value when the stencil computation accesses
a point outside the domain of the Pochoir array \id{array}.  The
Pochoir array \id{array} has $\id{dim}$ spatial dimensions, and
$\ang{\id{idx}_{\id{dim} - 1}, \ldots, \id{idx}_1, \id{idx}_0}$ are
the spatial coordinates of the given point outside the domain of
\id{array}.  The coordinate in the time dimension is given by
$\id{idx}_t$.  The function body $\ang{\id{definition}}$) is {C++}
code that defines the values of \id{array} on its boundary.  A current
restriction is that this construct must be declared outside of any
function, that is, the boundary function is declared global.
  
\begin{closeitemize}
\lstset{language=Pochoir_bf}
\item \code{Pochoir_Kernel_}\id{dim}\code{D}$(\id{name}, \id{array}, \linebreak[0]\id{idx}_t, \linebreak[0]\id{idx}_{\id{dim} - 1},\linebreak[0] \ldots,\linebreak[0] \id{idx}_1, \id{idx}_0)$ \\
     \hspace*{1em} $\ang{\id{definition}}$\\
     \code{Pochoir_Kernel_End}
\end{closeitemize}
This construct defines a \defn{kernel function} named \id{name} for
updating a stencil on a spatial grid with $\id{dim}$ spatial
dimensions. The spatial coordinates of the point to update are
$\ang{\id{idx}_{\id{dim} - 1}, \ldots, \id{idx}_1, \id{idx}_0}$, and
$\id{idx}_t$ is the coordinate in time dimension. The function body
$\ang{\id{definition}}$ may contain arbitrary {C++} code to compute
the stencil.  Unlike boundary functions, this construct can be defined
in any context.

\begin{closeitemize}
\lstset{language=Pochoir_bf}
\item \id{name}.\code{Register_Shape}$(\id{shape})$
\end{closeitemize}
The call to this member function of the Pochoir object \id{name}
informs \id{name} that the shape of the stencil associated with
\id{name} is given by the Pochoir shape \id{shape}.  A Pochoir array
cannot be registered with a Pochoir object for which a Pochoir shape
has not been previously registered.

\begin{closeitemize}
\lstset{language=Pochoir_bf}
\item \id{name}.\code{Register_Array}$(\id{array}, \id{bdry})$
\end{closeitemize}
A call to this member function of a Pochoir object \id{name} tells
\id{name} that the Pochoir array \id{array} will participate in its
stencil computation using boundary function \id{bdry}.  A Pochoir
shape must have already been registered for \id{name}.  Storage is
allocated for as many copies of \id{array} as is needed to implement
the stencil kernel as determined from the Pochoir shape.

\begin{closeitemize}
\lstset{language=Pochoir_bf}
\item \id{name}.\code{Run}$(T, \id{kern})$
\end{closeitemize} 
This function call runs the stencil computation on the Pochoir object
\id{name} for \id{T} time steps using computing kernel function
\id{kern}.

\subheading{Rationale}  

The Pochoir language is a product of many design decisions, some of
which were influenced by the current capabilities of the Intel 12.0.0
C++ compiler.  We now discuss some of the more important design
decisions.

Lambda functions are function objects of an implementation-dependent
type; this type's name is only available to the compiler. If the user
wishes to take a lambda function as a parameter, the type must be a
template type, or it must create a std::function to capture the lambda
value.

Although we chose to pass a kernel function to the \code{Run} method
of a Pochoir object, we would have preferred to simply store the
kernel function with the Pochoir object.  The kernel function is a C++
lambda function \cite{ISOIEC11}, however, whose type is not available to us.
Thus, although we can pass the lambda function as a template type, we
cannot store it unless we create a \code{std::function} to capture its
type.  Since the Intel compiler does not yet support
\code{std::function}, this avenue was lost to us.  There is only one
kernel function per Pochoir object, however, and so we decided as a
second-best alternative that it would be most convenient for users if
they could declare a kernel function in any context and we just pass
it as an argument to the \code{Run} member function.

The lack of support for function objects also had an impact on the
declaration of boundary functions.  We wanted to store each boundary
function with a Pochoir array so that whenever an access to the array
fall outside the computing domain, we can call the boundary function
to supply a value.  The only way to create a function that could be
stored is to use an ordinary function, which must be declared in a
global scope.  We hope to improve Pochoir's linguistic design when
function objects are fully supported by the compiler.

We chose to specify the kernel function imperatively rather than as a
pure function or an expression that returns a value for the grid point
being updated.  This approach allows a user to write multiple
statements in a kernel function and provides flexibility on how to
specify a stencil formula.  For example, the user can choose to
specify a stencil formula as
%
\code{a(t, i, j) = ...} or
%
\code{a(t+1, i, j) = ...}, whichever is more convenient.

We chose to make the user copy data in and out of Pochoir internal
data structures, rather than operate directly on the user's arrays.
Since the user is typically running the stencil computation for many
time steps, we decided that the copy-in/copy-out approach would not
cause much overhead.  Moreover, the layout of data is now under the
control of the compiler, allowing it to optimize the storage for cache
efficiency.

% LocalWords:  Neumann Pochoir nonperiodic runtime metaprogram variadic
% LocalWords:  Pochoir's
